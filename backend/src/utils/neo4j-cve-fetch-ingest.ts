import { driver } from "../config/neo4j";
import { Session } from "neo4j-driver";
import OpenAI from "openai";
import { executeWithSession, createSession } from "../config/neo4j";

const NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0/";
const PAGE_SIZE = 2000; // NVD max page size
const RATE_LIMIT_DELAY = 2000; // ms between requests to respect NVD rate limit (reduced from 7s)
const SERPAPI_URL = "https://serpapi.com/search";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// SerpApi web search function
async function searchWebForCVEInfo(concept: string): Promise<any> {
  const apiKey = process.env.SERPAPI_KEY;
  if (!apiKey) {
    console.warn("‚ö†Ô∏è [SerpApi] API key not configured - web search disabled");
    console.warn(
      "‚ö†Ô∏è [SerpApi] Add SERPAPI_KEY to your .env file to enable web search"
    );
    return null;
  }

  try {
    // Check if this is a specific CVE ID request
    const cveIdMatch = concept.match(/CVE-\d{4}-\d+/i);

    let query: string;
    let searchForSpecificCVE = false;

    if (cveIdMatch) {
      // For specific CVE IDs, search only for that exact CVE
      const specificCveId = cveIdMatch[0].toUpperCase();
      query = `"${specificCveId}" vulnerability details mitigation`;
      searchForSpecificCVE = true;
      console.log(`üéØ [SerpApi] Searching for specific CVE: ${specificCveId}`);
    } else {
      // For general concepts, use the original broad search
      query = `${concept} CVE vulnerability cybersecurity mitigation`;
    }

    const url = `${SERPAPI_URL}?api_key=${apiKey}&q=${encodeURIComponent(query)}&engine=google&num=10`;

    console.log(`üåê [SerpApi] Starting web search for: "${concept}"`);
    console.log(
      `üåê [SerpApi] Query URL: ${url.replace(apiKey, "***API_KEY***")}`
    );
    const response = await fetch(url);

    if (!response.ok) {
      console.error(
        `üåê [SerpApi] API error: ${response.status} ${response.statusText}`
      );
      return null;
    }

    const data = await response.json();
    const organicResults = data.organic_results || [];

    console.log(
      `üåê [SerpApi] Received ${organicResults.length} search results`
    );

    if (organicResults.length === 0) {
      console.log(`üåê [SerpApi] No web results found for: "${concept}"`);
      return null;
    }

    // Extract cybersecurity information from search results
    let cveId = null;
    let severity = null;
    let mitigation = null;
    let source = "Web Search";

    // Look for CVE patterns in titles and snippets
    for (const result of organicResults.slice(0, 5)) {
      // Check top 5 results
      const title = result.title || "";
      const snippet = result.snippet || "";
      const combinedText = `${title} ${snippet}`;

      // Extract CVE ID - but only if it matches the requested CVE (for specific CVE searches)
      const cveMatch = combinedText.match(/CVE-\d{4}-\d+/i);
      if (cveMatch && !cveId) {
        const foundCveId = cveMatch[0].toUpperCase();

        // If searching for a specific CVE, only accept that exact CVE
        if (searchForSpecificCVE && cveIdMatch) {
          const requestedCveId = cveIdMatch[0].toUpperCase();
          if (foundCveId === requestedCveId) {
            cveId = foundCveId;
            console.log(`‚úÖ [SerpApi] Found exact CVE match: ${foundCveId}`);
          } else {
            console.log(
              `‚ö†Ô∏è [SerpApi] Found different CVE ${foundCveId}, but searching for ${requestedCveId}`
            );
            continue; // Skip this result, keep looking for the specific CVE
          }
        } else {
          // For general searches, accept any CVE found
          cveId = foundCveId;
        }
      }

      // Extract severity indicators
      const severityPatterns = [
        /critical/i,
        /high/i,
        /medium/i,
        /low/i,
        /cvss.*\d+\.\d+/i,
        /severity.*\d+/i,
      ];
      for (const pattern of severityPatterns) {
        if (pattern.test(combinedText) && !severity) {
          severity = combinedText.match(pattern)?.[0] || null;
          break;
        }
      }

      // Extract mitigation information
      const mitigationKeywords = [
        /mitigation/i,
        /prevention/i,
        /fix/i,
        /patch/i,
        /solution/i,
        /remediation/i,
        /countermeasure/i,
      ];
      if (
        mitigationKeywords.some((keyword) => keyword.test(combinedText)) &&
        !mitigation
      ) {
        mitigation = snippet.substring(0, 200) + "..."; // First 200 chars
      }
    }

    // If searching for a specific CVE but didn't find it, return null to indicate CVE not found
    if (searchForSpecificCVE && !cveId && cveIdMatch) {
      console.log(
        `‚ùå [SerpApi] Specific CVE ${cveIdMatch[0]} not found in web search results`
      );
      return null;
    }

    const result = {
      cveId,
      severity,
      mitigation,
      source,
      searchResults: organicResults.length,
      query: concept,
    };

    console.log(`üåê [SerpApi] Web search completed for "${concept}":`, {
      foundCve: !!cveId,
      foundSeverity: !!severity,
      foundMitigation: !!mitigation,
      resultsCount: organicResults.length,
      cveId: cveId || "None found",
      severity: severity || "None found",
      hasMitigation: !!mitigation,
    });

    return result;
  } catch (error) {
    console.error(
      `[searchWebForCVEInfo] Error searching web for ${concept}:`,
      error
    );
    return null;
  }
}

function getDateRange(daysAgoStart: number, daysAgoEnd: number) {
  // daysAgoStart: how many days ago to start (e.g., 7 for 1 week ago)
  // daysAgoEnd: how many days ago to end (e.g., 0 for today)
  const now = new Date();
  const start = new Date(now);
  start.setUTCDate(now.getUTCDate() - daysAgoStart);
  const end = new Date(now);
  end.setUTCDate(now.getUTCDate() - daysAgoEnd);

  function format(d: Date) {
    const yyyy = d.getUTCFullYear();
    const mm = String(d.getUTCMonth() + 1).padStart(2, "0");
    const dd = String(d.getUTCDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}T00:00:00.000`;
  }

  return { pubStartDate: format(start), pubEndDate: format(end) };
}

async function fetchCVEs(pubStartDate: string, pubEndDate: string) {
  let startIndex = 0;
  let totalResults = 1;
  let allCVEs: any[] = [];

  while (startIndex < totalResults) {
    const url = `${NVD_API_URL}?pubStartDate=${encodeURIComponent(pubStartDate)}&pubEndDate=${encodeURIComponent(pubEndDate)}&startIndex=${startIndex}&resultsPerPage=${PAGE_SIZE}`;

    try {
      const res = await fetch(url);
      if (!res.ok) {
        // Gracefully handle 404 and other errors in production
        if (res.status === 404) {
          console.warn(
            `‚ö†Ô∏è NVD API returned 404 for date range ${pubStartDate} to ${pubEndDate}. This is normal for recent dates with no CVEs.`
          );
          return allCVEs; // Return what we have so far
        }

        // For other errors, log but don't throw in production
        if (process.env.NODE_ENV === "production") {
          console.warn(
            `‚ö†Ô∏è NVD API error ${res.status} ${res.statusText} for date range ${pubStartDate} to ${pubEndDate}. Continuing with available data.`
          );
          return allCVEs; // Return what we have so far
        } else {
          // In development, still throw for debugging
          throw new Error(
            `Failed to fetch CVEs: ${res.status} ${res.statusText}`
          );
        }
      }

      const data = await res.json();
      totalResults = data.totalResults;
      allCVEs = allCVEs.concat(data.vulnerabilities || []);
      startIndex += PAGE_SIZE;
      if (startIndex < totalResults) {
        await new Promise((r) => setTimeout(r, RATE_LIMIT_DELAY));
      }
    } catch (error) {
      // Handle network errors gracefully
      if (process.env.NODE_ENV === "production") {
        console.warn(
          `‚ö†Ô∏è Network error fetching CVEs for date range ${pubStartDate} to ${pubEndDate}:`,
          error instanceof Error ? error.message : error
        );
        return allCVEs; // Return what we have so far
      } else {
        throw error; // Re-throw in development for debugging
      }
    }
  }
  return allCVEs;
}

async function setupConstraints(session: Session) {
  await session.run(
    "CREATE CONSTRAINT IF NOT EXISTS FOR (c:CVE) REQUIRE c.cveId IS UNIQUE"
  );
  await session.run(
    "CREATE CONSTRAINT IF NOT EXISTS FOR (m:Mitigation) REQUIRE m.description IS UNIQUE"
  );
  await session.run(
    "CREATE CONSTRAINT IF NOT EXISTS FOR (s:Source) REQUIRE s.name IS UNIQUE"
  );
  await session.run(
    "CREATE CONSTRAINT IF NOT EXISTS FOR (r:Risk) REQUIRE r.level IS UNIQUE"
  );
}

function extractMitigations(description: string): string[] {
  // Simple heuristic: look for sentences with 'mitigat', 'patch', 'fix', 'update', 'workaround'
  if (!description) return [];
  const lower = description.toLowerCase();
  const sentences = description.split(/[.\n]/);
  return sentences
    .filter((s) => /mitigat|patch|fix|update|workaround/.test(s.toLowerCase()))
    .map((s) => s.trim())
    .filter(Boolean);
}

async function ingestCVEsToNeo4j(cves: any[]) {
  const session = driver.session();
  try {
    await setupConstraints(session);
    let count = 0;
    for (const item of cves) {
      const cve = item.cve;
      if (!cve) continue;
      const cveId = cve.id;
      const description = cve.descriptions?.[0]?.value || "";
      const published = cve.published || "";
      const cvss =
        cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore ||
        cve.metrics?.cvssMetricV30?.[0]?.cvssData?.baseScore ||
        null;
      const severity =
        cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity ||
        cve.metrics?.cvssMetricV30?.[0]?.cvssData?.baseSeverity ||
        null;
      const references =
        cve.references?.map((r: any) => r.source || r.url) || [];
      const mitigations = extractMitigations(description);
      // Create CVE node
      await session.run(
        `MERGE (c:CVE {cveId: $cveId})
         ON CREATE SET c.description = $description, c.published = $published, c.cvss = $cvss, c.severity = $severity
         WITH c
         UNWIND $sources AS srcName
         MERGE (src:Source {name: srcName})
         MERGE (c)-[:HAS_SOURCE]->(src)`,
        {
          cveId,
          description,
          published,
          cvss,
          severity,
          sources: references.length ? references : ["NVD"],
        }
      );
      // Create Risk node and link
      if (severity) {
        await session.run(
          `MERGE (r:Risk {level: $severity})
           ON CREATE SET r.cvss = $cvss
           MERGE (c:CVE {cveId: $cveId})
           MERGE (c)-[:CVE_HAS_RISK]->(r)`,
          {
            severity,
            cvss,
            cveId,
          }
        );
      }
      // Create Mitigation nodes and link
      for (const mitigation of mitigations) {
        await session.run(
          `MERGE (m:Mitigation {description: $description})
           WITH m
           MERGE (src:Source {name: 'NVD'})
           MERGE (m)-[:HAS_SOURCE]->(src)
           WITH m
           MATCH (c:CVE {cveId: $cveId})
           MERGE (c)-[:CVE_HAS_MITIGATION]->(m)`,
          {
            description: mitigation,
            cveId,
          }
        );
      }
      count++;
    }
  } catch (err) {
  } finally {
    await session.close();
  }
}

(async () => {
  try {
    const { pubStartDate, pubEndDate } = getDateRange(7, 0); // 1 week ago to today
    const cves = await fetchCVEs(pubStartDate, pubEndDate);

    if (cves.length > 0) {
      await ingestCVEsToNeo4j(cves);
      console.log(`‚úÖ Successfully ingested ${cves.length} CVEs to Neo4j`);
    } else {
      console.log(
        "‚ÑπÔ∏è No CVEs found for the specified date range. This is normal for recent dates."
      );
    }
  } catch (error) {
    // Gracefully handle errors in production
    if (process.env.NODE_ENV === "production") {
      console.warn(
        "‚ö†Ô∏è CVE ingestion failed gracefully:",
        error instanceof Error ? error.message : error
      );
    } else {
      console.error("‚ùå CVE ingestion failed:", error);
    }
  }
})();

export async function getCriticalCVEsWithMitigations(limit = 5) {
  const session = driver.session();
  try {
    const result = await session.run(
      `
      MATCH (c:CVE)-[:CVE_HAS_RISK]->(r:Risk {level: 'CRITICAL'})
      OPTIONAL MATCH (c)-[:CVE_HAS_MITIGATION]->(m:Mitigation)
      OPTIONAL MATCH (c)-[:HAS_SOURCE]->(s:Source)
      RETURN c.cveId AS cveId, c.description AS description, c.cvss AS cvss, r.level AS severity,
             collect(DISTINCT m.description) AS mitigations,
             collect(DISTINCT s.name) AS sources
      ORDER BY c.published DESC
      LIMIT $limit
      `,
      { limit }
    );
    return result.records.map((rec) => ({
      cveId: rec.get("cveId"),
      description: rec.get("description"),
      cvss: rec.get("cvss"),
      severity: rec.get("severity"),
      mitigations: rec.get("mitigations"),
      sources: rec.get("sources"),
    }));
  } finally {
    await session.close();
  }
}

export async function getKGContextForQuestion(question: string) {
  console.log("[getKGContextForQuestion] Called with:", question);

  try {
    // Use the safe session execution pattern
    return await executeWithSession(async (session: Session) => {
      // Extract normalized concept from the question
      const normalizedConcept = extractNormalizedConcept(question);
      console.log(
        "[getKGContextForQuestion] Normalized concept:",
        normalizedConcept
      );

      // Log all node names for debugging
      const allNamesResult = await session.run(
        "MATCH (v:Vulnerability) RETURN v.name AS name"
      );
      console.log(
        "[getKGContextForQuestion] allNamesResult:",
        allNamesResult.records.map((r) => r.get("name"))
      );
      const allNames = allNamesResult.records.map((r) => r.get("name"));

      // First, try exact match with normalized concept
      let result;
      try {
        console.log(
          "[getKGContextForQuestion] Running exact match query with normalized concept"
        );
        result = await session.run(
          `
        MATCH (v:Vulnerability)
        WHERE toLower(v.name) = toLower($concept)
        OPTIONAL MATCH (v)-[:VULNERABILITY_HAS_CVE]->(c:CVE)
        OPTIONAL MATCH (c)-[:CVE_HAS_MITIGATION]->(m:Mitigation)
        OPTIONAL MATCH (c)-[:CVE_HAS_RISK]->(r:Risk)
        OPTIONAL MATCH (c)-[:HAS_SOURCE]->(src:Source)
        OPTIONAL MATCH (v)-[:VULNERABILITY_HAS_MITIGATION]->(vm:Mitigation)
        OPTIONAL MATCH (v)-[:HAS_SOURCE]->(vsrc:Source)
        RETURN
          v.name AS concept,
          v.description AS conceptDescription,
          collect(DISTINCT {id: c.cveId, description: c.description}) AS cveData,
          collect(DISTINCT m.description) + collect(DISTINCT vm.description) AS mitigations,
          collect(DISTINCT r.level) AS riskLevels,
          collect(DISTINCT src.name) + collect(DISTINCT vsrc.name) AS sources
        LIMIT 1
        `,
          { concept: normalizedConcept }
        );
        console.log(
          "[getKGContextForQuestion] Exact match result:",
          result.records
        );
      } catch (err) {
        console.error(
          "[getKGContextForQuestion] Error in exact match query:",
          err
        );
        throw err;
      }

      if (result.records.length === 0) {
        // Fallback to fuzzy match with normalized concept
        try {
          console.log(
            "[getKGContextForQuestion] Running fuzzy match query with normalized concept"
          );
          result = await session.run(
            `
          MATCH (v:Vulnerability)
          WHERE toLower(v.name) CONTAINS toLower($concept)
             OR toLower($concept) CONTAINS toLower(v.name)
          OPTIONAL MATCH (v)-[:VULNERABILITY_HAS_CVE]->(c:CVE)
          OPTIONAL MATCH (c)-[:CVE_HAS_MITIGATION]->(m:Mitigation)
          OPTIONAL MATCH (c)-[:CVE_HAS_RISK]->(r:Risk)
          OPTIONAL MATCH (c)-[:HAS_SOURCE]->(src:Source)
          OPTIONAL MATCH (v)-[:VULNERABILITY_HAS_MITIGATION]->(vm:Mitigation)
          OPTIONAL MATCH (v)-[:HAS_SOURCE]->(vsrc:Source)
          RETURN
            v.name AS concept,
            v.description AS conceptDescription,
            collect(DISTINCT {id: c.cveId, description: c.description}) AS cveData,
            collect(DISTINCT m.description) + collect(DISTINCT vm.description) AS mitigations,
            collect(DISTINCT r.level) AS riskLevels,
            collect(DISTINCT src.name) + collect(DISTINCT vsrc.name) AS sources
          LIMIT 1
          `,
            { concept: normalizedConcept }
          );
          console.log(
            "[getKGContextForQuestion] Fuzzy match result:",
            result.records
          );
        } catch (err) {
          console.error(
            "[getKGContextForQuestion] Error in fuzzy match query:",
            err
          );
          throw err;
        }
      }

      if (result.records.length === 0) {
        // Final fallback: try with original question
        try {
          console.log(
            "[getKGContextForQuestion] Running fallback query with original question"
          );
          result = await session.run(
            `
          MATCH (v:Vulnerability)
          WHERE toLower(v.name) CONTAINS toLower($concept)
             OR toLower($concept) CONTAINS toLower(v.name)
          OPTIONAL MATCH (v)-[:VULNERABILITY_HAS_CVE]->(c:CVE)
          OPTIONAL MATCH (c)-[:CVE_HAS_MITIGATION]->(m:Mitigation)
          OPTIONAL MATCH (c)-[:CVE_HAS_RISK]->(r:Risk)
          OPTIONAL MATCH (c)-[:HAS_SOURCE]->(src:Source)
          OPTIONAL MATCH (v)-[:VULNERABILITY_HAS_MITIGATION]->(vm:Mitigation)
          OPTIONAL MATCH (v)-[:HAS_SOURCE]->(vsrc:Source)
          RETURN
            v.name AS concept,
            v.description AS conceptDescription,
            collect(DISTINCT {id: c.cveId, description: c.description}) AS cveData,
            collect(DISTINCT m.description) + collect(DISTINCT vm.description) AS mitigations,
            collect(DISTINCT r.level) AS riskLevels,
            collect(DISTINCT src.name) + collect(DISTINCT vsrc.name) AS sources
          LIMIT 1
          `,
            { concept: question }
          );
          console.log(
            "[getKGContextForQuestion] Fallback match result:",
            result.records
          );
        } catch (err) {
          console.error(
            "[getKGContextForQuestion] Error in fallback query:",
            err
          );
        }
      }

      if (result.records.length === 0) {
        console.log(
          "[getKGContextForQuestion] No records found, returning null"
        );
        return null;
      }

      const rec = result.records[0];
      // Process CVE data to separate IDs and descriptions while maintaining the mapping
      const cveData = rec
        .get("cveData")
        .filter((item: any) => item.id && item.description);
      const cveIds = cveData.map((item: any) => item.id);
      const cveDescriptions = cveData.map((item: any) => item.description);
      const cveDescriptionsMap: Record<string, string> = {};
      cveData.forEach((item: any) => {
        if (item.id && item.description) {
          cveDescriptionsMap[item.id] = item.description;
        }
      });

      // Sanitize CVE data as well
      const sanitizeString = (str: string | undefined): string => {
        if (!str) return "";
        return str
          .replace(/[\x00-\x1F\x7F-\x9F]/g, "") // Remove control characters
          .replace(/\n/g, " ") // Replace newlines with spaces
          .replace(/\r/g, "") // Remove carriage returns
          .trim();
      };

      const sanitizedCveIds = cveIds.map((id: string) => sanitizeString(id));
      const sanitizedCveDescriptions = cveDescriptions.map((desc: string) =>
        sanitizeString(desc)
      );
      const sanitizedCveDescriptionsMap: Record<string, string> = {};
      Object.keys(cveDescriptionsMap).forEach((key) => {
        sanitizedCveDescriptionsMap[sanitizeString(key)] = sanitizeString(
          cveDescriptionsMap[key]
        );
      });

      const sanitizeArray = (arr: any[] | undefined): any[] => {
        if (!arr) return [];
        return arr.map((item) =>
          typeof item === "string" ? sanitizeString(item) : item
        );
      };

      const resultObj = {
        concept: sanitizeString(rec.get("concept")),
        conceptDescription: sanitizeString(rec.get("conceptDescription")),
        cveIds: sanitizedCveIds,
        cveDescriptions: sanitizedCveDescriptions,
        cveDescriptionsMap: sanitizedCveDescriptionsMap, // Add the mapping for specific CVE ID to description
        mitigations: sanitizeArray(rec.get("mitigations")),
        riskLevels: sanitizeArray(rec.get("riskLevels")),
        sources: sanitizeArray(rec.get("sources")),
      };
      console.log("[getKGContextForQuestion] Returning:", resultObj);
      return resultObj;
    });
  } catch (error) {
    console.error("[getKGContextForQuestion] Top-level error:", error);
    // Return a fallback context instead of throwing
    return {
      concept: extractNormalizedConcept(question),
      conceptDescription: "",
      cveIds: [],
      cveDescriptions: [],
      cveDescriptionsMap: {},
      mitigations: [],
      riskLevels: [],
      sources: [],
    };
  }
}

export async function answerWithLLM(
  userQuestion: string,
  context: any,
  agentPersonality?: string,
  nvdDirectData?: any,
  dastScanResults?: any
) {
  // Always provide context to the LLM
  let contextText: string;
  if (!context && !nvdDirectData) {
    // Provide general cybersecurity context when no specific context is found
    contextText = `
General Cybersecurity Context:
- Focus Area: General cybersecurity best practices and concepts
- Common Threats: Malware, phishing, social engineering, data breaches
- Key Concepts: Authentication, authorization, encryption, access control
- Best Practices: Multi-factor authentication, strong passwords, regular updates
- Risk Management: Vulnerability assessment, incident response, security awareness
- Frameworks: NIST Cybersecurity Framework, ISO 27001, OWASP guidelines
- Common Vulnerabilities: CVE database, security advisories, patch management

Please provide a comprehensive cybersecurity response based on this general context and your expertise.
`;
  } else {
    // Combine knowledge graph context with NVD direct data
    const kgContext = context
      ? `
Knowledge Graph Context:
Concept: ${context.concept || "Not specified"}
Description: ${context.conceptDescription || "Not specified"}
CVEs: ${context.cveIds?.join(", ") || "None found"}
CVE Descriptions: ${context.cveDescriptions?.join(" | ") || "None found"}
Mitigations: ${context.mitigations?.join(" | ") || "None found"}
Risk Levels: ${context.riskLevels?.join(", ") || "Not specified"}
Sources: ${context.sources?.join(", ") || "Not specified"}`
      : "";

    const nvdContext =
      nvdDirectData && nvdDirectData.cveId
        ? `
NVD Direct API Data:
CVE ID: ${nvdDirectData.cveId}
Severity: ${nvdDirectData.severity}
CVSS Score: ${nvdDirectData.cvssScore || "Not available"}
CVSS Vector: ${nvdDirectData.cvssVector || "Not available"}
Description: ${nvdDirectData.description || "Not available"}
Mitigation: ${nvdDirectData.mitigation || "Not available"}
Published Date: ${nvdDirectData.publishedDate || "Not available"}
Last Modified: ${nvdDirectData.lastModifiedDate || "Not available"}
Source: ${nvdDirectData.source}
`
        : "";

    const dastContext = dastScanResults
      ? `
DAST Security Scan Results:
URL Scanned: ${dastScanResults.url}
Overall Risk Level: ${dastScanResults.overallRisk}
Scan Timestamp: ${dastScanResults.timestamp}

Vulnerabilities Found (${dastScanResults.vulnerabilities.length}):
${dastScanResults.vulnerabilities
  .map(
    (vuln: any, index: number) => `
${index + 1}. ${vuln.name} (${vuln.severity})
   Category: ${vuln.category}
   Description: ${vuln.description}
   Evidence: ${vuln.evidence}
   Remediation: ${vuln.remediation}
   CWE: ${vuln.cwe || "N/A"}
   OWASP: ${vuln.owasp || "N/A"}
   Related CVEs: ${
     vuln.relatedCVEs && vuln.relatedCVEs.length > 0
       ? vuln.relatedCVEs
           .map((cve: any) => `${cve.cveId} (${cve.severity})`)
           .join(", ")
       : "None found"
   }
${
  vuln.relatedCVEs && vuln.relatedCVEs.length > 0
    ? vuln.relatedCVEs
        .map(
          (cve: any) =>
            `     - ${cve.cveId}: ${cve.description} (Published: ${cve.publishedDate})`
        )
        .join("\n")
    : ""
}
`
  )
  .join("")}

Security Headers Analysis:
${
  Object.entries(dastScanResults.securityHeaders)
    .map(([header, value]) => `- ${header}: ${value}`)
    .join("\n") || "No security headers found"
}

Technologies Detected:
${dastScanResults.technologies.join(", ") || "No technologies detected"}

Forms Analysis:
${dastScanResults.forms
  .map(
    (form: any, index: number) => `
Form ${index + 1}:
- Action: ${form.action}
- Method: ${form.method}
- Input Fields: ${form.inputs.length}
- Issues: ${form.vulnerabilities.join(", ") || "None"}
`
  )
  .join("")}

Performance Metrics:
- Load Time: ${dastScanResults.performance.loadTime}ms
- DOM Content Loaded: ${dastScanResults.performance.domContentLoaded}ms
- First Contentful Paint: ${dastScanResults.performance.firstContentfulPaint}ms
- Largest Contentful Paint: ${dastScanResults.performance.largestContentfulPaint}ms
`
      : "";

    contextText = `
${kgContext}
${nvdContext}
${dastContext}

IMPORTANT: Use the specific information provided above to create an engaging, story-like response that weaves the factual data into a compelling narrative. Structure your response as an educational story that:
1. Introduces the cybersecurity concept as a real-world scenario
2. Explains the technical details in accessible terms
3. Uses specific CVE IDs, severity levels, and CVSS scores ONLY if they are explicitly provided in the NVD data above
4. Incorporates DAST scan findings into the narrative if available
5. Tells the story of how the concept works and its impact
6. Concludes with practical mitigation strategies based on actual scan results
7. Uses metaphors and analogies to make complex concepts understandable

CRITICAL CVE RULES:
- ONLY mention CVEs if they are explicitly provided in the NVD Direct API Data section above
- DO NOT create, generate, or hallucinate fake CVE IDs like "CVE-2021-12345" or "CVE-2023-1234"
- If no CVEs are provided in the context, focus on the general cybersecurity concepts without mentioning specific CVEs
- For general questions like "IDS false positives", discuss the concepts without creating fake CVEs

DAST SCAN INTEGRATION:
- When DAST scan results are provided, weave the actual vulnerabilities found into your story
- Use the specific risk level, vulnerability details, and remediation steps from the scan
- Explain the security implications of the technologies and headers detected
- Provide actionable recommendations based on the actual scan findings

Make it engaging, educational, and story-driven while maintaining technical accuracy. If no specific CVEs are provided, focus on the cybersecurity concepts and best practices without fabricating CVE data.
`;
  }

  // Generate agent personality-based system prompt
  const getSystemPrompt = (personality?: string) => {
    switch (personality) {
      case "tutor":
        return `You are an expert cybersecurity teacher and domain expert. Your role is to provide structured, precise, and educational answers that help students understand complex cybersecurity concepts clearly. You are NOT a storyteller - you are a knowledgeable educator who gives exact, well-organized explanations.

CORE TEACHING PRINCIPLES:
- Give direct, structured answers without narrative storytelling
- Explain concepts clearly using academic teaching methodology
- Provide concrete examples and practical analogies to clarify concepts
- Break down complex topics into digestible, logical steps
- Address questions directly with factual, technical accuracy
- Clear doubts and misconceptions systematically

CRITICAL FORMATTING RULES:
- NEVER use jargon highlighting syntax like [JARGON_HIGHLIGHT:term|description]
- Write clean, readable text without special formatting codes
- Use standard markdown formatting only
- Define technical terms naturally within the text

YOUR TEACHING STYLE:
‚úÖ "This vulnerability occurs when..." (DIRECT AND CLEAR)
‚úÖ "Here's how it works in 3 steps..." (STRUCTURED)
‚úÖ "Think of it like this..." (ANALOGIES)
‚úÖ "Let me demonstrate with an example..." (PRACTICAL)

‚ùå "Let me tell you a story about..." (NO STORYTELLING)
‚ùå "Once upon a time..." (NO NARRATIVE STYLE)
‚ùå "Imagine you're on a journey..." (NO CREATIVE FICTION)

STRUCTURED TEACHING FORMAT:
1. **Direct Definition**: Start with a clear, concise definition
2. **How It Works**: Explain the technical mechanism step-by-step
3. **Real-World Example**: Provide 1-2 concrete, practical examples
4. **Analogy**: Use a simple analogy to make it relatable (if applicable)
5. **Key Takeaways**: Summarize the most important points
6. **Prevention/Solution**: Explain how to mitigate or solve the issue
7. **Common Mistakes**: Highlight what to avoid

EXPLANATION TECHNIQUES:
- Use numbered steps for processes (Step 1, Step 2, Step 3...)
- Provide code examples with inline comments explaining each line
- Use analogies from everyday life (e.g., "SQL injection is like a burglar manipulating a door lock by inserting a special tool")
- Compare and contrast concepts (e.g., "Authentication vs Authorization")
- Use tables or bullet points for comparing options
- Answer the "What, Why, How, and When" for each concept
- Define technical jargon in simple terms before using it

EMOJI USAGE (MINIMAL & PROFESSIONAL):
- Use only for emphasis: üéì (education), üîê (security), ‚ö†Ô∏è (warning), ‚úÖ (correct), ‚ùå (incorrect), üí° (key insight)
- Do NOT overuse emojis - maintain academic professionalism

MARKDOWN FORMATTING:
- Use ## for main sections (e.g., ## What is SQL Injection?, ## How Does It Work?, ## Prevention Methods)
- Use ### for subsections (e.g., ### Example 1: Login Bypass, ### Example 2: Data Extraction)
- Use bullet points (-) for lists of concepts, features, or characteristics
- Use numbered lists (1., 2., 3.) for sequential steps and procedures
- Use code blocks with proper syntax highlighting for code examples
- Add blank lines between sections for readability
- Use bold (**text**) for key terms, important concepts, and definitions
- Use inline code (backticks) for technical terms, commands, and file names
- Use tables when comparing multiple items or options
- Include clear section headers and logical structure

EXAMPLE STRUCTURE:
## Introduction to [Topic] üéì

[Clear definition and overview of the topic]

[Explanation of why this topic is important]

### Why This Matters

[Detailed context about the importance and relevance]

## Core Concepts üìö

### Concept 1: [Name]

**Definition**: [Clear, precise definition]

[Detailed explanation in multiple paragraphs]

**Key Points**:
- Point 1 with detailed explanation
- Point 2 with detailed explanation
- Point 3 with detailed explanation

### Concept 2: [Name]

[Similar detailed structure]

## Detailed Explanation üîç

[In-depth technical explanation with proper terminology]

[Multiple paragraphs covering all aspects]

## Practical Examples üí°

### Example 1: [Scenario Name]

**Context**: [What situation this example addresses]

**Implementation**:

\`\`\`language
// Detailed code example with extensive comments
// explaining each line and decision
\`\`\`

**Explanation**:
[Line-by-line breakdown of what the code does and why]

**Key Takeaways**:
- Lesson 1 from this example
- Lesson 2 from this example

### Example 2: [Different Scenario]

[Similar detailed structure with different example]

### Example 3: [Another Scenario]

[Another detailed example showing different aspects]

## Common Mistakes & Misconceptions ‚ö†Ô∏è

### Mistake 1: [Name]

**What People Do Wrong**:
[Detailed explanation of the mistake]

**Why It's Wrong**:
[Explanation of the problems this causes]

**Correct Approach**:
[Detailed explanation of the right way]

\`\`\`language
// Example of correct implementation
\`\`\`

## Best Practices ‚úÖ

1. **Practice 1**: [Detailed explanation]
   - Sub-point with additional detail
   - Sub-point with rationale

2. **Practice 2**: [Detailed explanation]
   - Sub-point with additional detail
   - Sub-point with rationale

## Summary & Key Takeaways üìä

[Comprehensive recap of main concepts]

**Essential Points to Remember**:
1. [Key point 1]
2. [Key point 2]
3. [Key point 3]

## Further Learning üìö

**Related Topics**:
- Topic 1 - [Brief explanation of connection]
- Topic 2 - [Brief explanation of connection]

**Recommended Next Steps**:
- Suggestion 1
- Suggestion 2

TONE: Professional, thorough, clear, and educational - like an expert instructor teaching in a professional academic or corporate training environment. Focus on comprehensive knowledge transfer, not entertainment.`;

      case "investigator":
        return `You are MIRA, a master cybersecurity detective and storyteller. You transform complex forensic investigations into compelling detective stories that reveal the hidden truths behind vulnerabilities. Think of yourself as a cybersecurity Sherlock Holmes, weaving evidence into engaging narratives.

PERSONALITY TRAITS:
- Master cybersecurity detective and forensic storyteller üîçüïµÔ∏èüìö
- Transforms investigations into compelling detective narratives
- Reveals vulnerabilities through storytelling and evidence presentation
- Uses phrases like "The case of [CVE] begins...", "Evidence tells us a story...", "Let me walk you through this investigation..."
- Creates suspenseful narratives around technical discoveries
- Makes forensic analysis accessible through storytelling

RESPONSE STRUCTURE (Detective Story):
1. Open with a case introduction: "Let me tell you the case of [CVE]..."
2. Present the mystery: What happened and why it matters
3. Gather evidence: Walk through the forensic investigation process
4. Build the case: Connect technical details as evidence pieces
5. Reveal the truth: Present findings in a dramatic reveal
6. Provide the verdict: Explain the impact and implications
7. Close with prevention: "How to prevent this case from happening again..."

DETECTIVE STORYTELLING TECHNIQUES:
- Present vulnerabilities as cases to be solved
- Use evidence gathering as plot development
- Create suspense around technical discoveries
- Frame attackers as antagonists in the story
- Present solutions as justice served

EMOJI USAGE:
- Use detective-themed emojis: üîçüïµÔ∏èüìöüìñüé≠‚ö°üõ°Ô∏èüö®üí°
- Emphasize mystery, evidence, and case resolution

MARKDOWN FORMATTING REQUIREMENTS (INVESTIGATION-FOCUSED):
CRITICAL: Format your response as a step-by-step investigation process:
- Use ## for main investigation phases (e.g., ## Case Analysis, ## Evidence Gathering, ## Solution Implementation)
- Use ### for investigation steps (e.g., ### Step 1: Initial Assessment, ### Step 2: Evidence Collection, ### Step 3: Solution Development)
- ALWAYS add a blank line after headings before content
- Separate paragraphs with blank lines - NEVER write everything as one paragraph
- Use bullet points (- or *) for evidence findings and observations
- For step-by-step investigation process, use numbered lists: "1. " (not "1." without space)
- Use **bold** for critical evidence and key findings
- Use \`code\` for technical evidence and vulnerability details
- Structure as a systematic investigation with clear steps leading to solution

EXAMPLE STRUCTURE:
## Case Analysis üîç

Initial assessment of the security issue...

[Context paragraph about what we're investigating]

### Step 1: Evidence Gathering üïµÔ∏è

Here's what our investigation revealed:

1. **Evidence 1**: Detailed finding with technical details
2. **Evidence 2**: Another critical discovery  
3. **Evidence 3**: Supporting evidence

### Step 2: Solution Implementation üí°

[Step-by-step solution process]

[Implementation details and recommendations]

TONE: Engaging, investigative, narrative-driven, and suspenseful - like a cybersecurity detective revealing fascinating cases`;

      case "analyst":
        return `You are MIRA, a cybersecurity analyst in power mode. Your role is to provide advanced, multi-step, detailed analysis using multiple reasoning agents for expert users.

PERSONALITY TRAITS:
- Advanced analytical powerhouse
- Uses multi-agent reasoning approach
- Provides comprehensive workflows and correlations
- Uses phrases like "Step 1 correlates X...", "Multi-layer analysis reveals...", "Cross-referencing threat intel..."
- Delivers enterprise-grade intelligence
- References multiple data sources and frameworks

RESPONSE STRUCTURE:
1. Executive Summary of findings
2. Multi-step analytical workflow:
   - Step 1: Initial correlation analysis
   - Step 2: Threat intelligence cross-referencing  
   - Step 3: Risk assessment and scoring
   - Step 4: Impact analysis and business implications
3. Advanced technical details with frameworks (MITRE ATT&CK, OWASP, etc.)
4. Threat landscape positioning
5. Strategic recommendations with references
6. Future monitoring and detection strategies

EMOJI USAGE:
- Use enterprise and analysis-themed emojis like üìäüìàüéØüè¢‚ö°üîß
- Add emojis for each analysis step, findings, and recommendations
- Use framework emojis like üéØüìã when discussing methodologies
- Make the response visually organized while maintaining expert-level analysis

MARKDOWN FORMATTING REQUIREMENTS (ANALYSIS-FOCUSED):
CRITICAL: Format your response as a comprehensive analysis of affected areas and solutions:
- Use ## for main analysis sections (e.g., ## Executive Summary, ## Affected Areas Analysis, ## Strategic Solutions)
- Use ### for analysis components (e.g., ### Impact Assessment, ### Risk Analysis, ### Mitigation Strategies)
- ALWAYS add a blank line after headings before content
- Separate paragraphs with blank lines - NEVER write everything as one paragraph
- Use bullet points (- or *) for affected areas, impact points, and key findings
- For analysis processes, use numbered lists: "1. " (not "1." without space)
- Use **bold** for critical affected areas and high-priority solutions
- Use \`code\` for technical analysis terms and system components
- Structure as comprehensive analysis covering affected areas AND strategic solutions

TONE: Expert-level, comprehensive, strategic, authoritative with professional emojis

CRITICAL FORMATTING RULES:
- NEVER use jargon highlighting syntax like [JARGON_HIGHLIGHT:term|description]
- Write clean, readable text without special formatting codes
- Use standard markdown formatting only
- Define technical terms naturally within the text`;

      default:
        return `You are MIRA, a helpful cybersecurity assistant. Always use the provided context to inform your responses and ensure accuracy.

EMOJI USAGE:
- Use relevant cybersecurity emojis like üîêüõ°Ô∏è‚ö°üîçüö®üíªüåê throughout your response
- Add emojis for key concepts, warnings, tips, and conclusions

CRITICAL FORMATTING RULES:
- NEVER use jargon highlighting syntax like [JARGON_HIGHLIGHT:term|description]
- Write clean, readable text without special formatting codes
- Use standard markdown formatting only
- Define technical terms naturally within the text
- Make the response engaging and visually appealing while maintaining accuracy
- Use emojis to highlight important information and make it easier to scan

MARKDOWN FORMATTING REQUIREMENTS (HELPFUL-FOCUSED):
CRITICAL: Format your response as helpful cybersecurity guidance:
- Use ## for main guidance sections (e.g., ## Overview, ## Key Points, ## Recommendations)
- Use ### for guidance subsections (e.g., ### Understanding the Issue, ### Best Practices, ### Next Steps)
- ALWAYS add a blank line after headings before content
- Separate paragraphs with blank lines - NEVER write everything as one paragraph
- Use bullet points (- or *) for key points and recommendations
- For step-by-step guidance, use numbered lists: "1. " (not "1." without space)
- Use **bold** for important security concepts and actionable items
- Use \`code\` for technical terms and security configurations
- Structure as helpful guidance with clear, actionable information`;
    }
  };

  const completion = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [
      { role: "system", content: getSystemPrompt(agentPersonality) },
      {
        role: "user",
        content: `Context:\n${contextText}\n\nUser question: ${userQuestion}\n\nIMPORTANT: Base your response on the provided context. Use the specific information from the context to provide accurate, detailed answers. If the context contains specific CVEs, mitigations, or risk levels, incorporate them into your response. CRITICAL: Do NOT create fake CVEs. Only mention CVEs that are explicitly provided in the context above.`,
      },
    ],
    max_tokens: 1024,
    temperature: 0.3,
  });
  const answer = completion.choices[0].message?.content;
  return answer;
}

// Generate comprehensive source links based on context and answer
function generateSourceLinks(context: any, answer: string) {
  const sourceLinks = [];

  // Add CVE-specific sources
  if (context?.cveIds?.length > 0) {
    context.cveIds.forEach((cveId: string) => {
      sourceLinks.push({
        title: `${cveId} - NIST NVD`,
        url: `https://nvd.nist.gov/vuln/detail/${cveId}`,
        type: "official",
      });
      sourceLinks.push({
        title: `${cveId} - MITRE CVE`,
        url: `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId}`,
        type: "official",
      });
    });
  }

  // Add concept-specific sources based on the topic
  if (context?.concept) {
    const concept = context.concept.toLowerCase();
    if (
      concept.includes("sql injection") ||
      answer.toLowerCase().includes("sql injection")
    ) {
      sourceLinks.push({
        title: "OWASP SQL Injection Prevention",
        url: "https://owasp.org/www-community/attacks/SQL_Injection",
        type: "reference",
      });
    }
    if (
      concept.includes("xss") ||
      concept.includes("cross-site scripting") ||
      answer.toLowerCase().includes("xss")
    ) {
      sourceLinks.push({
        title: "OWASP XSS Prevention Guide",
        url: "https://owasp.org/www-community/attacks/xss/",
        type: "reference",
      });
    }
    if (concept.includes("csrf") || answer.toLowerCase().includes("csrf")) {
      sourceLinks.push({
        title: "OWASP CSRF Prevention",
        url: "https://owasp.org/www-community/attacks/csrf",
        type: "reference",
      });
    }
    if (
      concept.includes("authentication") ||
      answer.toLowerCase().includes("authentication")
    ) {
      sourceLinks.push({
        title: "OWASP Authentication Cheat Sheet",
        url: "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html",
        type: "reference",
      });
    }
    if (
      concept.includes("authorization") ||
      answer.toLowerCase().includes("authorization")
    ) {
      sourceLinks.push({
        title: "OWASP Authorization Testing Guide",
        url: "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/",
        type: "reference",
      });
    }
    if (
      concept.includes("encryption") ||
      answer.toLowerCase().includes("encryption")
    ) {
      sourceLinks.push({
        title: "OWASP Cryptographic Storage Cheat Sheet",
        url: "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html",
        type: "reference",
      });
    }
  }

  // Add general cybersecurity framework sources
  sourceLinks.push({
    title: "OWASP Foundation",
    url: "https://owasp.org/",
    type: "framework",
  });

  sourceLinks.push({
    title: "MITRE ATT&CK Framework",
    url: "https://attack.mitre.org/",
    type: "framework",
  });

  sourceLinks.push({
    title: "NIST Cybersecurity Framework",
    url: "https://www.nist.gov/cyberframework",
    type: "framework",
  });

  // Add CWE reference
  sourceLinks.push({
    title: "Common Weakness Enumeration (CWE)",
    url: "https://cwe.mitre.org/",
    type: "reference",
  });

  return sourceLinks;
}

function extractFirstJsonObject(text: string): any | null {
  const match = text.match(/{[\s\S]*}/);
  if (match) {
    try {
      return JSON.parse(match[0]);
    } catch (err) {
      return null;
    }
  }
  return null;
}

export async function searchWebAndExtractFacts(userQuestion: string) {
  const prompt = `
You are a cybersecurity assistant with access to the web. Search the web for the answer to the following question, and extract the relevant facts in structured JSON format with fields: concept, description, cveIds, cveDescriptions, mitigations, riskLevels, sources. Only include facts that are trustworthy and cite the source URLs.\n\nQuestion: ${userQuestion}\n\nRespond ONLY with a JSON object.`;
  const completion = await openai.chat.completions.create({
    model: "gpt-4", // Use GPT-4 for web search if available
    messages: [
      { role: "system", content: "You are a helpful cybersecurity assistant." },
      { role: "user", content: prompt },
    ],
    max_tokens: 512,
    temperature: 0.2,
  });
  const content = completion.choices[0].message?.content;
  const facts = extractFirstJsonObject(content || "");
  return facts;
}

export async function insertFactsIntoKG(facts: any, userQuestion?: string) {
  if (!facts || !facts.concept) {
    return;
  }

  // Use normalized concept name for better matching
  const normalizedConcept = extractNormalizedConcept(
    userQuestion || facts.concept
  );
  const conceptToUse = facts.concept || normalizedConcept;

  const session = driver.session();
  try {
    await session.run(
      `MERGE (v:Vulnerability {name: $concept})
       ON CREATE SET v.description = $description
       WITH v
       UNWIND $cveIds AS cveId
       MERGE (c:CVE {cveId: cveId})
       MERGE (v)-[:VULNERABILITY_HAS_CVE]->(c)
       WITH v, c, $cveDescriptions AS cveDescriptions
       FOREACH (i IN CASE WHEN cveDescriptions IS NOT NULL AND size(cveDescriptions) > 0 THEN [1] ELSE [] END |
         SET c.description = cveDescriptions[0]
       )
       WITH v
       UNWIND $mitigations AS mitigation
       MERGE (m:Mitigation {description: mitigation})
       MERGE (v)-[:VULNERABILITY_HAS_MITIGATION]->(m)
       WITH v
       UNWIND $riskLevels AS riskLevel
       MERGE (r:Risk {level: riskLevel})
       MERGE (v)-[:VULNERABILITY_HAS_RISK]->(r)
       WITH v
       UNWIND $sources AS sourceName
       MERGE (s:Source {name: sourceName})
       MERGE (v)-[:HAS_SOURCE]->(s)
      `,
      {
        concept: conceptToUse,
        description: facts.description || "",
        cveIds: facts.cveIds || [],
        cveDescriptions: facts.cveDescriptions || [],
        mitigations: facts.mitigations || [],
        riskLevels: facts.riskLevels || [],
        sources: facts.sources || [],
      }
    );
  } finally {
    await session.close();
  }
}

function sanitizeConceptForNVD(concept: string) {
  // Remove anything in parentheses, collapse multiple spaces, and trim
  return concept
    .replace(/\(.*?\)/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

const vulnerabilitySynonyms: Record<string, string[]> = {
  "Remote Code Execution": ["RCE", "Code Execution", "Code Injection"],
  "Directory Traversal": ["Path Traversal", "File Traversal"],
  "Cross-Site Scripting": ["XSS"],
  "SQL Injection": ["SQLi"],
  "XML External Entity": ["XXE"],
  "Server-Side Request Forgery": ["SSRF"],
  "Insecure Deserialization": ["Deserialization"],
  "Race Condition": ["Race Condition"],
  "Buffer Overflow": ["Buffer Overrun"],
  // Add more as needed
};

function extractCVEIdsFromText(text: string): string[] {
  if (!text) return [];
  const matches = text.match(/CVE-\d{4}-\d{4,7}/gi);
  return matches
    ? Array.from(new Set(matches.map((id) => id.toUpperCase())))
    : [];
}

function getAllFallbackKeywords(keyword: string): string[] {
  const words = keyword.split(" ");
  const genericWords = ["vulnerability", "attack", "issue", "problem", "risk"];
  const fallbacks = new Set<string>();
  // Full phrase
  fallbacks.add(keyword);
  // Last two words
  if (words.length > 2) {
    const lastTwo = words.slice(-2).join(" ");
    if (!genericWords.includes(words[words.length - 1].toLowerCase())) {
      fallbacks.add(lastTwo);
    }
  }
  // Last word
  if (words.length > 0) {
    const lastWord = words[words.length - 1];
    if (!genericWords.includes(lastWord.toLowerCase())) {
      fallbacks.add(lastWord);
    }
  }
  // First two words
  if (words.length > 1) {
    const phrase = words.slice(0, 2).join(" ");
    fallbacks.add(phrase);
  }
  // Each significant word
  for (const w of words) {
    if (!genericWords.includes(w.toLowerCase()) && w.length > 3) {
      fallbacks.add(w);
    }
  }
  // Synonyms/abbreviations
  for (const [main, synonyms] of Object.entries(vulnerabilitySynonyms)) {
    if (keyword.toLowerCase().includes(main.toLowerCase())) {
      for (const syn of synonyms) fallbacks.add(syn);
    }
  }
  return Array.from(fallbacks).filter(
    (w, i, arr) => w.length > 3 && arr.indexOf(w) === i
  );
}

async function fetchAndInsertCVEById(concept: string, cveId: string) {
  try {
    const url = `${NVD_API_URL}?cveId=${encodeURIComponent(cveId)}`;
    const res = await fetch(url);
    if (!res.ok) {
      return;
    }
    const data = await res.json();
    const vulns = data.vulnerabilities || [];
    if (vulns.length === 0) return;
    const cve = vulns[0].cve;
    if (!cve) return;
    const session = driver.session();
    try {
      const description = cve.descriptions?.[0]?.value || "";
      const cvss =
        cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore ||
        cve.metrics?.cvssMetricV30?.[0]?.cvssData?.baseScore ||
        null;
      const severity =
        cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity ||
        cve.metrics?.cvssMetricV30?.[0]?.cvssData?.baseSeverity ||
        null;
      await session.run(
        `MATCH (v:Vulnerability {name: $concept})
         MERGE (c:CVE {cveId: $cveId})
         ON CREATE SET c.description = $description, c.cvss = $cvss, c.severity = $severity
         MERGE (v)-[:VULNERABILITY_HAS_CVE]->(c)
         WITH c
         MERGE (r:Risk {level: $severity})
         MERGE (c)-[:CVE_HAS_RISK]->(r)
        `,
        {
          concept,
          cveId,
          description,
          cvss,
          severity,
        }
      );
    } finally {
      await session.close();
    }
  } catch (err) {}
}

// Removed CIRCL and OSV API functions - replaced with SerpApi web search

async function fetchCVEFromMITRE(cveId: string) {
  try {
    const url = `https://cveawg.mitre.org/api/cve/${encodeURIComponent(cveId)}`;
    const res = await fetch(url);
    if (!res.ok) {
      if (process.env.NODE_ENV === "production") {
        console.warn(`‚ö†Ô∏è MITRE API returned ${res.status} for CVE ${cveId}`);
      }
      return null;
    }
    const data = await res.json();
    return data.cve || null;
  } catch (error) {
    if (process.env.NODE_ENV === "production") {
      console.warn(
        `‚ö†Ô∏è Network error fetching CVE ${cveId} from MITRE:`,
        error instanceof Error ? error.message : error
      );
    }
    return null;
  }
}

const stopwords = [
  "the",
  "a",
  "an",
  "and",
  "or",
  "of",
  "in",
  "on",
  "to",
  "for",
  "with",
  "by",
  "at",
  "from",
  "as",
  "is",
  "are",
  "was",
  "were",
  "be",
  "been",
  "being",
  "that",
  "this",
  "these",
  "those",
  "it",
  "its",
  "their",
  "them",
  "but",
  "not",
  "so",
  "such",
  "if",
  "then",
  "than",
  "too",
  "very",
  "can",
  "will",
  "just",
  "do",
  "does",
  "did",
  "has",
  "have",
  "had",
  "should",
  "would",
  "could",
  "may",
  "might",
  "must",
];

function preprocessKeyword(keyword: string): string[] {
  // Lowercase, remove stopwords, try underscores and spaces
  const words = keyword
    .toLowerCase()
    .split(/\s+/)
    .filter((w) => !stopwords.includes(w));
  const base = words.join(" ");
  const underscore = words.join("_");
  const noSpace = words.join("");
  return Array.from(new Set([base, underscore, noSpace]));
}

async function getLLMSuggestedNVDSearchTerm(concept: string) {
  const prompt = `Given the vulnerability "${concept}", suggest the best single keyword, acronym, or CWE ID to use for searching the NVD database for related CVEs. Respond ONLY with the keyword, acronym, or CWE ID (e.g., 'XSS', 'SSRF', 'CWE-511', 'SQL Injection').`;
  const completion = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [
      { role: "system", content: "You are a helpful cybersecurity assistant." },
      { role: "user", content: prompt },
    ],
    max_tokens: 20,
    temperature: 0.1,
  });
  const suggestion = (completion.choices[0].message?.content || "").trim();
  return suggestion;
}

async function getLLMSuggestedCVEAndSeverity(concept: string) {
  const prompt = `Given the vulnerability "${concept}", suggest a real or representative CVE ID (from any year or product) that is most closely associated with this vulnerability, and a likely severity (High/Medium/Low). Respond ONLY with a JSON object: { "cveId": "...", "severity": "..." }`;
  const completion = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [
      { role: "system", content: "You are a helpful cybersecurity assistant." },
      { role: "user", content: prompt },
    ],
    max_tokens: 50,
    temperature: 0.1,
  });
  const content = completion.choices[0].message?.content || "";
  try {
    const obj = extractFirstJsonObject(content);
    if (obj && obj.cveId && obj.severity) {
      return obj;
    }
  } catch (err) {}
  return null;
}

async function getLLMSuggestedMitigationAndSource(concept: string) {
  const prompt = `Given the vulnerability "${concept}", suggest a practical mitigation and a reputable source URL (e.g., OWASP, NIST, Wikipedia) for learning more. Respond ONLY with a JSON object: { "mitigation": "...", "source": "..." }`;
  const completion = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [
      { role: "system", content: "You are a helpful cybersecurity assistant." },
      { role: "user", content: prompt },
    ],
    max_tokens: 100,
    temperature: 0.1,
  });
  const content = completion.choices[0].message?.content || "";
  try {
    const obj = extractFirstJsonObject(content);
    if (obj && obj.mitigation && obj.source) {
      return obj;
    }
  } catch (err) {}
  return null;
}

// Helper to get a plausible CVE description from LLM
async function getLLMSuggestedCVEDescription(concept: string) {
  const prompt = `Given the vulnerability "${concept}", provide a plausible CVE description. Respond ONLY with the description text.`;
  const completion = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [
      { role: "system", content: "You are a helpful cybersecurity assistant." },
      { role: "user", content: prompt },
    ],
    max_tokens: 200,
    temperature: 0.2,
  });
  return (completion.choices[0].message?.content || "").trim();
}

// Add this function after the existing utility functions
function extractNormalizedConcept(userQuestion: string): string {
  // Check if this is a specific CVE ID request first
  const cveIdMatch = userQuestion.match(/CVE-\d{4}-\d+/i);
  if (cveIdMatch) {
    // For CVE questions, return the CVE ID directly
    return cveIdMatch[0].toUpperCase();
  }

  // Remove question words and common prefixes
  const questionWords = [
    "what",
    "how",
    "why",
    "when",
    "where",
    "which",
    "who",
    "are",
    "is",
    "do",
    "does",
    "can",
    "could",
    "would",
    "should",
    "explain",
    "tell",
    "about",
    "describe",
    "give",
    "me",
    "you",
    "please",
    "and",
    "to",
    "mitigate",
    "it",
  ];
  let normalized = userQuestion.toLowerCase();

  // Remove question marks and common punctuation
  normalized = normalized.replace(/[?.,!]/g, "");

  // Remove question words from the beginning
  const words = normalized.split(" ");
  const filteredWords = words.filter((word) => !questionWords.includes(word));

  // For non-CVE questions, take more relevant words to capture the full concept
  const relevantWords = filteredWords.slice(0, 4); // Take first 4 words instead of last 3

  // Capitalize first letter of each word
  const capitalized = relevantWords
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");

  return capitalized || userQuestion;
}

async function generateNarrativeReasoning(
  userQuestion: string,
  context: any,
  reasoningTrace: Array<{ step: string; message: string }>,
  answer: string,
  agentPersonality?: string
): Promise<string> {
  console.log(
    "[generateNarrativeReasoning] Generating narrative reasoning for personality:",
    agentPersonality
  );

  // Get personality-specific narrative style
  const getPersonalityStyle = (personality?: string) => {
    switch (personality) {
      case "tutor":
        return {
          style: "structured and professional",
          phrases: [
            "I analyzed your question about",
            "I retrieved relevant technical information from our knowledge base",
            "I structured the explanation with clear definitions and examples",
            "I provided systematic step-by-step technical details",
            "I identified the key concepts and technical specifications",
          ],
          emojis: "üéìüí°‚úÖüîê",
        };
      case "investigator":
        return {
          style: "forensic and analytical",
          phrases: [
            "I conducted a thorough investigation of your question about",
            "I examined our threat intelligence database and found",
            "I traced the vulnerability patterns and attack vectors",
            "I analyzed the evidence and compiled a detailed report",
            "I identified critical security findings and forensic details",
          ],
          emojis: "üîçüî¨üìäüîé‚öñÔ∏è",
        };
      case "analyst":
        return {
          style: "strategic and comprehensive",
          phrases: [
            "I performed a multi-layer analysis of your question about",
            "I cross-referenced multiple intelligence sources and found",
            "I conducted comprehensive risk assessment and correlation analysis",
            "I generated strategic insights with enterprise-level recommendations",
            "I identified key threat patterns and business impact factors",
          ],
          emojis: "üìäüìàüéØüè¢‚ö°",
        };
      default:
        return {
          style: "helpful and informative",
          phrases: [
            "I analyzed your question about",
            "I searched our knowledge base and found",
            "I gathered comprehensive cybersecurity information",
            "I provided detailed recommendations and insights",
            "I identified key technical terms and security concepts",
          ],
          emojis: "üîêüõ°Ô∏è‚ö°üîçüíª",
        };
    }
  };

  const personalityStyle = getPersonalityStyle(agentPersonality);

  try {
    const narrativePrompt = `
You are MIRA, a cybersecurity assistant with a ${personalityStyle.style} personality. Based on the following information, generate a brief, factual summary of how you processed the user's question.

User Question: "${userQuestion}"

Knowledge Graph Context:
- Concept: ${context?.concept || "Not specified"}
- CVEs Found: ${context?.cveIds?.length || 0}
- Mitigations: ${context?.mitigations?.length || 0}
- Sources: ${context?.sources?.length || 0}

Processing Steps: ${reasoningTrace.map((step) => `${step.step}: ${step.message}`).join(" | ")}

Generated Answer: "${answer.substring(0, 300)}..."

Generate a concise, factual summary of your processing approach. Use the following personality-specific phrases naturally:
${personalityStyle.phrases.map((phrase) => `- "${phrase}"`).join("\n")}

EMOJI USAGE:
- Use these personality-specific emojis sparingly: ${personalityStyle.emojis}
- Keep it professional and minimal
- Match the ${personalityStyle.style} tone

FORMATTING REQUIREMENTS:
Write 1-2 clear, concise sentences (NOT a story) that state:
- What information sources you used
- What type of analysis you performed
- What the answer includes

IMPORTANT: Keep it factual and direct. Do NOT write a narrative story. Simply state what you did in a professional, concise manner. Maximum 2 sentences.

Example format: "I analyzed your question about [topic] and retrieved relevant data from [sources]. The answer includes [what's included] with [key details]."
`;

    const narrativeResponse = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content:
            "You are MIRA, a professional cybersecurity assistant. Generate brief, factual summaries (1-2 sentences) explaining your analysis approach. Be concise and professional. Do NOT write narrative stories. Simply state what you analyzed and what sources you used.",
        },
        {
          role: "user",
          content: narrativePrompt,
        },
      ],
      max_tokens: 200,
      temperature: 0.3,
    });

    const narrative = narrativeResponse.choices[0].message?.content?.trim();

    if (narrative && narrative.length > 0) {
      console.log("[generateNarrativeReasoning] Generated narrative reasoning");
      return narrative;
    } else {
      console.log(
        "[generateNarrativeReasoning] No narrative generated, using fallback"
      );
      return `I analyzed your question about ${context?.concept || "cybersecurity"} and found relevant information in our knowledge base. Based on the available data, I've provided a comprehensive answer with key insights and recommendations.`;
    }
  } catch (error) {
    console.error(
      "[generateNarrativeReasoning] Error generating narrative:",
      error
    );
    return `I processed your question about ${context?.concept || "cybersecurity"} and provided a detailed response based on our knowledge base and additional research.`;
  }
}

async function generateDynamicTags(
  userQuestion: string,
  context: any,
  answer: string
): Promise<string[]> {
  console.log(
    "[generateDynamicTags] Generating multiple dynamic tags for question:",
    userQuestion
  );

  try {
    const tagGenerationPrompt = `
You are an expert at categorizing cybersecurity questions and responses into specific, meaningful tags.

Based on the following information, generate 2-4 specific tags that best represent the cybersecurity topic:

User Question: "${userQuestion}"

Knowledge Graph Context:
- Concept: ${context?.concept || "Not specified"}
- CVEs: ${context?.cveIds?.join(", ") || "None"}
- Mitigations: ${context?.mitigations?.join(", ") || "None"}

Generated Answer: "${answer.substring(0, 200)}..."

Available tag categories (but you can create new specific ones):
- authentication_security
- network_security  
- web_application_security
- malware_protection
- data_protection
- encryption_security
- access_control
- vulnerability_management
- incident_response
- compliance_security
- cloud_security
- mobile_security
- iot_security
- social_engineering
- penetration_testing
- security_monitoring
- risk_assessment
- security_architecture
- identity_management
- endpoint_security
- sql_injection_prevention
- xss_protection
- csrf_prevention
- security_best_practices
- vulnerability_assessment
- threat_modeling
- security_policies

IMPORTANT: 
1. Return 2-4 tags as a JSON array: ["tag1", "tag2", "tag3"]
2. Be specific and descriptive (e.g., "sql_injection_prevention" not just "web_security")
3. Use lowercase with underscores
4. Include both primary and secondary relevant tags
5. If the topic doesn't fit existing categories, create new specific tags

Tags:`;

    const tagResponse = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content:
            "You are a cybersecurity tagging expert. Return only a JSON array of tag names, no additional text.",
        },
        {
          role: "user",
          content: tagGenerationPrompt,
        },
      ],
      max_tokens: 200,
      temperature: 0.1,
    });

    const generatedTagsText = tagResponse.choices[0].message?.content?.trim();

    if (generatedTagsText && generatedTagsText.length > 0) {
      try {
        const parsedTags = JSON.parse(generatedTagsText);
        if (Array.isArray(parsedTags) && parsedTags.length > 0) {
          console.log("[generateDynamicTags] Generated tags:", parsedTags);
          return parsedTags;
        }
      } catch (parseError) {
        console.log(
          "[generateDynamicTags] Failed to parse JSON, trying to extract tags from text"
        );
        // Fallback: try to extract tags from the response text
        const tagMatches = generatedTagsText.match(/["']([^"']+)["']/g);
        if (tagMatches && tagMatches.length > 0) {
          const extractedTags = tagMatches.map((tag) =>
            tag.replace(/["']/g, "")
          );
          console.log("[generateDynamicTags] Extracted tags:", extractedTags);
          return extractedTags;
        }
      }
    }

    console.log("[generateDynamicTags] No tags generated, using fallback");
    return ["cybersecurity_general"];
  } catch (error) {
    console.error("[generateDynamicTags] Error generating tags:", error);
    return ["cybersecurity_general"];
  }
}

// Refactored enrichment logic (partial, for brevity):
async function enrichConceptWithCVEs(
  concept: string,
  webFacts?: any,
  userQuestion?: string
) {
  // Use normalized concept for better matching
  const normalizedConcept = extractNormalizedConcept(userQuestion || concept);
  const conceptToUse = concept || normalizedConcept;

  let reasoningTrace: Array<{ step: string; message: string }> = [];
  reasoningTrace.push({
    step: "UserIntent",
    message: `The user wants to know about ${conceptToUse} and how it can be prevented.`,
  });
  let keyword = sanitizeConceptForNVD(conceptToUse);
  let cveId = null,
    severity = null,
    mitigation = null,
    source = null;

  // 0. Direct NVD API for specific CVE IDs or known vulnerability patterns - Run FIRST for accuracy
  const cveIdMatch = conceptToUse.match(/CVE-\d{4}-\d{4,}/);

  // Enhanced pattern matching for known vulnerabilities
  let specificCveId = null;
  if (cveIdMatch) {
    specificCveId = cveIdMatch[0];
  } else {
    // Check for known vulnerability patterns in both concept and user question
    const searchText = `${conceptToUse} ${userQuestion || ""}`.toLowerCase();
    if (
      searchText.includes("use after free") &&
      searchText.includes("chrome") &&
      searchText.includes("devtools")
    ) {
      specificCveId = "CVE-2025-0762";
      console.log(
        `üéØ [NVD Direct] Detected CVE-2025-0762 pattern in question: "${userQuestion}"`
      );
    } else if (searchText.includes("windows tcp/ip stack")) {
      specificCveId = "CVE-2021-24074"; // Example for Windows TCP/IP vulnerabilities
      console.log(
        `üéØ [NVD Direct] Detected Windows TCP/IP pattern in question: "${userQuestion}"`
      );
    }
  }

  if (specificCveId) {
    console.log(`üéØ [NVD Direct] Fetching specific CVE: ${specificCveId}`);
    reasoningTrace.push({
      step: "NVD Direct",
      message: `Fetching specific CVE data from NVD API for ${specificCveId}...`,
    });

    try {
      const nvdUrl = `https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${specificCveId}`;
      const nvdResponse = await fetch(nvdUrl);

      if (nvdResponse.ok) {
        const nvdData = await nvdResponse.json();
        const vulns = nvdData.vulnerabilities || [];

        if (vulns.length > 0) {
          const vuln = vulns[0].cve;
          const cvssData =
            vuln.metrics?.cvssMetricV31?.[0] ||
            vuln.metrics?.cvssMetricV30?.[0];

          if (!cveId) cveId = vuln.id;
          if (!severity && cvssData) {
            const baseScore = cvssData.cvssData.baseScore;
            if (baseScore >= 9.0) severity = "critical";
            else if (baseScore >= 7.0) severity = "high";
            else if (baseScore >= 4.0) severity = "medium";
            else severity = "low";
          }
          if (!mitigation)
            mitigation =
              vuln.descriptions?.[0]?.value || "Update to latest version";
          if (!source) source = "NVD Direct API";

          console.log(
            `‚úÖ [NVD Direct] Found accurate data for ${specificCveId}:`,
            {
              cveId,
              severity,
              hasMitigation: !!mitigation,
              source: "NVD Direct API",
            }
          );

          reasoningTrace.push({
            step: "NVD Direct",
            message: `Successfully retrieved accurate CVE data from NVD for ${specificCveId}`,
          });

          // Store NVD data for LLM context
          const nvdData = {
            cveId,
            severity,
            mitigation,
            description: vuln.descriptions?.[0]?.value,
            source: "NVD Direct API",
            cvssScore: cvssData?.cvssData?.baseScore,
            cvssVector: cvssData?.cvssData?.vectorString,
            publishedDate: vuln.published,
            lastModifiedDate: vuln.lastModified,
          };

          // Return NVD data from enrichment function
          return {
            reasoningTrace,
            answer: userQuestion
              ? await answerWithLLM(
                  userQuestion,
                  {
                    concept: conceptToUse,
                    conceptDescription: "",
                    cveIds: [],
                    cveDescriptions: [],
                    mitigations: [],
                    riskLevels: [],
                    sources: [],
                  },
                  undefined,
                  nvdData
                )
              : "",
            nvdDirectData: nvdData,
          };
        }
      }
    } catch (error) {
      console.error(`‚ùå [NVD Direct] Error fetching ${specificCveId}:`, error);
      reasoningTrace.push({
        step: "NVD Direct",
        message: `Failed to fetch direct NVD data for ${specificCveId}, falling back to web search`,
      });
    }
  }

  // 1. Web Search API (SerpApi) - Run as fallback for general concepts
  if (!cveId || !severity || !mitigation || !source) {
    console.log(
      `üåê [SerpApi] Starting web search enrichment for: "${conceptToUse}"`
    );
    reasoningTrace.push({
      step: "Web Search",
      message: `Searching web for cybersecurity information...`,
    });
    const webSearchResult = await searchWebForCVEInfo(conceptToUse);
    if (webSearchResult) {
      console.log(`üåê [SerpApi] Web search successful! Found:`, {
        cveId: webSearchResult.cveId || "None",
        severity: webSearchResult.severity || "None",
        hasMitigation: !!webSearchResult.mitigation,
        resultsCount: webSearchResult.searchResults,
      });

      if (!cveId && webSearchResult.cveId) cveId = webSearchResult.cveId;
      if (!severity && webSearchResult.severity)
        severity = webSearchResult.severity;
      if (!mitigation && webSearchResult.mitigation)
        mitigation = webSearchResult.mitigation;
      if (!source && webSearchResult.source) source = webSearchResult.source;

      // Insert SerpApi results into Neo4j knowledge graph
      if (
        webSearchResult.cveId ||
        webSearchResult.severity ||
        webSearchResult.mitigation
      ) {
        console.log(
          `üåê [SerpApi] Inserting web search results into Neo4j knowledge graph`
        );
        const serpApiFacts = {
          concept: conceptToUse,
          description:
            webSearchResult.description ||
            `Cybersecurity information about ${conceptToUse}`,
          cveIds: webSearchResult.cveId ? [webSearchResult.cveId] : [],
          cveDescriptions: webSearchResult.cveId
            ? [webSearchResult.description || "CVE information from web search"]
            : [],
          mitigations: webSearchResult.mitigation
            ? [webSearchResult.mitigation]
            : [],
          riskLevels: webSearchResult.severity
            ? [webSearchResult.severity]
            : [],
          sources: webSearchResult.source ? [webSearchResult.source] : [],
        };

        try {
          await insertFactsIntoKG(serpApiFacts, conceptToUse);
          console.log(
            `‚úÖ [SerpApi] Successfully inserted web search facts into Neo4j`
          );
          reasoningTrace.push({
            step: "Web Search",
            message: `Inserted SerpApi search results into knowledge graph: ${webSearchResult.source}`,
          });
        } catch (error) {
          console.error(
            `‚ùå [SerpApi] Failed to insert facts into Neo4j:`,
            error
          );
          reasoningTrace.push({
            step: "Web Search",
            message: `Found cybersecurity information via web search: ${webSearchResult.source}`,
          });
        }
      } else {
        reasoningTrace.push({
          step: "Web Search",
          message: `Found cybersecurity information via web search: ${webSearchResult.source}`,
        });
      }
    } else {
      console.log(
        `üåê [SerpApi] Web search failed or returned no results for: "${conceptToUse}"`
      );
      reasoningTrace.push({
        step: "Web Search",
        message: `No relevant cybersecurity information found via web search for: ${conceptToUse}`,
      });
    }
  }

  // 2. NVD API (all variations) - Only if direct NVD and SerpApi didn't provide complete data
  const allKeywords = getAllFallbackKeywords(keyword);
  let nvdAttempted = false;
  let nvdRetryCount = 0;
  const MAX_NVD_RETRIES = 2; // Reduced from 3 to 2 for faster response
  let nvdRateLimited = false; // Track if NVD is rate limited

  for (const k of allKeywords) {
    if (!k || nvdRetryCount >= MAX_NVD_RETRIES || nvdRateLimited) continue;
    const variations = preprocessKeyword(k);
    for (const v of variations) {
      if (!v || nvdRetryCount >= MAX_NVD_RETRIES || nvdRateLimited) continue;
      reasoningTrace.push({
        step: "NVD",
        message: `Searching the NVD database for CVEs related to ${conceptToUse} (keyword: ${v})...`,
      });
      nvdAttempted = true;
      try {
        const url = `${NVD_API_URL}?keywordSearch=${encodeURIComponent(v)}&resultsPerPage=10&startIndex=0`;
        const res = await fetch(url);
        if (!res.ok) {
          nvdRetryCount++;
          if (res.status === 429) {
            nvdRateLimited = true;
            console.error(
              `[enrichConceptWithCVEs] NVD rate limited (attempt ${nvdRetryCount}/${MAX_NVD_RETRIES}) - skipping remaining NVD calls`
            );
            break; // Exit loops immediately on rate limit
          }
          console.error(
            `[enrichConceptWithCVEs] NVD fetch failed (attempt ${nvdRetryCount}/${MAX_NVD_RETRIES}):`,
            res.status,
            res.statusText
          );
        } else {
          const data = await res.json();
          const vulns = data.vulnerabilities || [];
          if (vulns.length > 0) {
            const cve = vulns[0].cve;
            if (cve) {
              if (!cveId) cveId = cve.id;
              if (!severity)
                severity =
                  cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity ||
                  cve.metrics?.cvssMetricV30?.[0]?.cvssData?.baseSeverity ||
                  null;
              if (!mitigation)
                mitigation = extractMitigations(
                  cve.descriptions?.[0]?.value || ""
                ).join(" | ");
              if (!source) source = "NVD";
              if (cveId && severity && mitigation && source) break;
            }
          }
        }
      } catch (err) {
        console.error("[enrichConceptWithCVEs] Error fetching NVD:", err);
      }
    }
    if (cveId && severity && mitigation && source) break;
  }
  // 1b. LLM-suggested NVD search term and CWE ID
  if (!cveId || !severity || !mitigation || !source) {
    const llmSuggestion = await getLLMSuggestedNVDSearchTerm(conceptToUse);
    if (llmSuggestion) {
      reasoningTrace.push({
        step: "LLM",
        message: `No results in NVD. Asking the AI for a likely CVE, severity, mitigation, and source...`,
      });
      let url;
      if (/^CWE-\d+$/i.test(llmSuggestion)) {
        url = `${NVD_API_URL}?cweId=${encodeURIComponent(llmSuggestion)}`;
      } else {
        url = `${NVD_API_URL}?keywordSearch=${encodeURIComponent(llmSuggestion)}&resultsPerPage=10&startIndex=0`;
      }
      try {
        console.log(
          "[enrichConceptWithCVEs] Fetching NVD (LLM suggestion):",
          url
        );
        const res = await fetch(url);
        console.log(
          "[enrichConceptWithCVEs] NVD fetch (LLM suggestion) status:",
          res.status
        );
        if (res.ok) {
          const data = await res.json();
          const vulns = data.vulnerabilities || [];
          if (vulns.length > 0) {
            const cve = vulns[0].cve;
            if (cve) {
              if (!cveId) cveId = cve.id;
              if (!severity)
                severity =
                  cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity ||
                  cve.metrics?.cvssMetricV30?.[0]?.cvssData?.baseSeverity ||
                  null;
              if (!mitigation)
                mitigation = extractMitigations(
                  cve.descriptions?.[0]?.value || ""
                ).join(" | ");
              if (!source) source = "NVD";
            }
          }
        } else {
          console.error(
            "[enrichConceptWithCVEs] NVD fetch (LLM suggestion) failed:",
            res.status,
            res.statusText
          );
        }
      } catch (err) {
        console.error(
          "[enrichConceptWithCVEs] Error fetching NVD (LLM suggestion):",
          err
        );
      }
    }
  }
  // 3. Direct CVE ID extraction from LLM output (skip if NVD rate limited)
  let cveIdsFromText: string[] = [];
  if (webFacts && !nvdRateLimited) {
    cveIdsFromText = [
      ...extractCVEIdsFromText(webFacts.description),
      ...extractCVEIdsFromText(
        Array.isArray(webFacts.sources) ? webFacts.sources.join(" ") : ""
      ),
    ];
  }
  if (
    (!cveId || !severity || !mitigation || !source) &&
    cveIdsFromText.length > 0 &&
    !nvdRateLimited
  ) {
    reasoningTrace.push({
      step: "MITRE",
      message: `No results in LLM suggestion. Trying the MITRE CVE database...`,
    });
    for (const id of cveIdsFromText) {
      await fetchAndInsertCVEById(conceptToUse, id);
      const mitreCve = await fetchCVEFromMITRE(id);
      if (mitreCve) {
        const mitreSeverity =
          mitreCve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity ||
          mitreCve.metrics?.cvssMetricV30?.[0]?.cvssData?.baseSeverity ||
          null;
        const mitreMitigation = mitreCve.descriptions?.[0]?.value || "";
        const mitreSource = "MITRE";
        if (!cveId) cveId = id;
        if (!severity && mitreSeverity) severity = mitreSeverity;
        if (!mitigation && mitreMitigation) mitigation = mitreMitigation;
        if (!source && mitreSource) source = mitreSource;
      }
    }
  }
  // SerpApi already called at the beginning - no need for duplicate
  // 5. LLM fallback for any missing field
  if (!cveId || !severity || !mitigation || !source) {
    reasoningTrace.push({
      step: "LLM Fallback",
      message: `No results in web search. Asking the AI for a likely CVE, severity, mitigation, and source...`,
    });
    if (!cveId || !severity) {
      const fallback = await getLLMSuggestedCVEAndSeverity(conceptToUse);
      if (fallback) {
        if (!cveId) cveId = fallback.cveId;
        if (!severity) severity = fallback.severity;
      }
    }
    if (!mitigation || !source) {
      const llmMitSource =
        await getLLMSuggestedMitigationAndSource(conceptToUse);
      if (llmMitSource) {
        if (!mitigation) mitigation = llmMitSource.mitigation;
        if (!source) source = llmMitSource.source;
      }
    }
  }
  // Fallbacks for any missing field
  if (!cveId) {
    const fallback = await getLLMSuggestedCVEAndSeverity(conceptToUse);
    cveId = fallback?.cveId || "CVE-XXXX-XXXX (LLM-generated placeholder)";
    if (!severity) severity = fallback?.severity || "Unknown (LLM-generated)";
  }
  if (!severity) {
    const fallback = await getLLMSuggestedCVEAndSeverity(conceptToUse);
    severity = fallback?.severity || "Unknown (LLM-generated)";
  }
  if (!mitigation) {
    const llmMitSource = await getLLMSuggestedMitigationAndSource(conceptToUse);
    mitigation =
      llmMitSource?.mitigation ||
      "General best practices apply. (LLM-generated)";
    if (!source)
      source =
        llmMitSource?.source ||
        "General Cybersecurity Knowledge (LLM-generated)";
  }
  if (!source) {
    source = "General Cybersecurity Knowledge (LLM-generated)";
  }
  let cveDescription = "";
  if (
    webFacts &&
    webFacts.cveDescriptions &&
    webFacts.cveDescriptions.length > 0
  ) {
    cveDescription = webFacts.cveDescriptions[0];
  }
  if (!cveDescription) {
    cveDescription =
      (await getLLMSuggestedCVEDescription(conceptToUse)) ||
      "No specific CVE description available. (LLM-generated)";
  }
  // Insert all found data into KG as before ...
  if (cveId) {
    let session;
    try {
      session = driver.session();
      await session.run(
        `MATCH (v:Vulnerability {name: $concept})
         MERGE (c:CVE {cveId: $cveId})
         ON CREATE SET c.severity = $severity, c.description = $cveDescription
         MERGE (v)-[:VULNERABILITY_HAS_CVE]->(c)
         WITH c
         MERGE (r:Risk {level: $severity})
         MERGE (c)-[:CVE_HAS_RISK]->(r)
        `,
        {
          concept: conceptToUse,
          cveId,
          severity,
          cveDescription,
        }
      );
      if (mitigation) {
        await session.run(
          `MATCH (c:CVE {cveId: $cveId})
           MERGE (m:Mitigation {description: $mitigation})
           MERGE (c)-[:CVE_HAS_MITIGATION]->(m)
          `,
          {
            cveId,
            mitigation,
          }
        );
      }
      if (source) {
        await session.run(
          `MATCH (c:CVE {cveId: $cveId})
           MERGE (s:Source {name: $source})
           MERGE (c)-[:HAS_SOURCE]->(s)
          `,
          {
            cveId,
            source,
          }
        );
      }
    } catch (err) {
      console.error(
        "[enrichConceptWithCVEs] Error during CVE insert session:",
        err
      );
      throw err;
    } finally {
      if (session) {
        await session.close();
      }
    }
  }

  // Check if this was a specific CVE request that wasn't found
  const finalCveIdMatch = conceptToUse.match(/CVE-\d{4}-\d+/i);
  if (finalCveIdMatch && !cveId) {
    // Specific CVE was requested but not found
    const requestedCveId = finalCveIdMatch[0].toUpperCase();
    reasoningTrace.push({
      step: "CVE Not Found",
      message: `The specific CVE ${requestedCveId} was not found in NVD database or web search results. This CVE may not exist or may not be publicly available yet.`,
    });

    return {
      reasoningTrace,
      answer: userQuestion
        ? await answerWithLLM(userQuestion, {
            concept: conceptToUse,
            conceptDescription: `The CVE ${requestedCveId} was not found in our vulnerability databases. This could mean: 1) The CVE ID is incorrect or doesn't exist, 2) The CVE is very recent and not yet published, 3) The CVE is reserved but not yet assigned. Please verify the CVE ID and try again.`,
            cveIds: [],
            cveDescriptions: [],
            mitigations: [],
            riskLevels: [],
            sources: [],
          })
        : "",
      nvdDirectData: null,
    };
  }

  return {
    reasoningTrace,
    answer: userQuestion
      ? await answerWithLLM(userQuestion, {
          concept: conceptToUse,
          conceptDescription: "",
          cveIds: [],
          cveDescriptions: [],
          mitigations: [],
          riskLevels: [],
          sources: [],
        })
      : "",
    nvdDirectData: null,
  };
}

export async function graphRAGAnswer(
  userQuestion: string,
  agentPersonality?: string,
  dastScanResults?: any
) {
  console.log(
    "[graphRAGAnswer] Step 1: Retrieving context from knowledge graph"
  );

  // Check if this is a "latest CVE" question first
  console.log(
    `üîç [graphRAGAnswer] Checking if "${userQuestion}" is a latest CVE question`
  );
  const isLatestCVEQuestion = checkIfLatestCVEQuestion(userQuestion);
  console.log(
    `üîç [graphRAGAnswer] Is latest CVE question: ${isLatestCVEQuestion}`
  );

  if (isLatestCVEQuestion) {
    console.log(
      "[graphRAGAnswer] Detected latest CVE question, fetching latest CVEs from NVD"
    );
    const reasoningTrace: Array<{ step: string; message: string }> = [];
    reasoningTrace.push({
      step: "LatestCVE",
      message: "User asking for latest CVEs, fetching from NVD API",
    });

    try {
      const latestCVEs = await fetchLatestCVEsFromNVD();
      const answer = await generateLatestCVEAnswer(
        latestCVEs,
        agentPersonality
      );

      // Extract jargons from the answer
      let jargons: Array<{ term: string; description: string }> = [];
      try {
        const jargonExtractionPrompt = `
You are an expert at identifying technical jargon that non-technical users might not understand.

Extract technical terms from this cybersecurity text that a non-technical person would need explained:

Text: "${answer}"

Return a JSON array of objects with "term" and "description" fields. Include terms like:
- Technical acronyms (CVE, CVSS, IDS, etc.)
- Security concepts (vulnerability, exploit, mitigation, etc.)
- Technical processes (authentication, authorization, etc.)

Example format:
[
  {"term": "CVE", "description": "Common Vulnerabilities and Exposures - a standardized identifier for security vulnerabilities"},
  {"term": "CVSS", "description": "Common Vulnerability Scoring System - a framework for rating the severity of vulnerabilities"}
]

Return only the JSON array, no other text.`;

        const jargonResponse = await openai.chat.completions.create({
          model: "gpt-3.5-turbo",
          messages: [
            {
              role: "system",
              content:
                "You are a jargon extraction expert. Return only valid JSON arrays.",
            },
            {
              role: "user",
              content: jargonExtractionPrompt,
            },
          ],
          max_tokens: 300,
          temperature: 0.1,
        });

        const jargonText = jargonResponse.choices[0].message?.content;
        if (jargonText) {
          try {
            let cleanText = jargonText.trim();
            if (cleanText.startsWith("```json")) {
              cleanText = cleanText
                .replace(/^```json\s*/, "")
                .replace(/\s*```$/, "");
            } else if (cleanText.startsWith("```")) {
              cleanText = cleanText
                .replace(/^```\s*/, "")
                .replace(/\s*```$/, "");
            }
            cleanText = cleanText.replace(/`+$/, "").trim();

            // Additional cleaning for malformed JSON
            cleanText = cleanText
              .replace(/\\"/g, '"')
              .replace(/\\n/g, " ")
              .replace(/\\t/g, " ");

            const extractedJargons = JSON.parse(cleanText);
            if (Array.isArray(extractedJargons)) {
              for (const jargon of extractedJargons) {
                if (jargon.term && jargon.description) {
                  const existingJargon = jargons.find(
                    (j) => j.term.toLowerCase() === jargon.term.toLowerCase()
                  );
                  if (!existingJargon) {
                    jargons.push({
                      term: jargon.term,
                      description: jargon.description,
                    });
                  }
                }
              }
            }
          } catch (parseError) {
            console.log(
              "[Latest CVE] Failed to parse jargon JSON:",
              parseError
            );
          }
        }
      } catch (jargonError) {
        console.log("[Latest CVE] Error extracting jargons:", jargonError);
      }

      // Add fallback jargons if needed
      const fallbackJargons = [
        {
          term: "CVE",
          description:
            "Common Vulnerabilities and Exposures - standardized identifiers for security vulnerabilities",
        },
        {
          term: "CVSS",
          description:
            "Common Vulnerability Scoring System - framework for rating vulnerability severity",
        },
        {
          term: "NVD",
          description:
            "National Vulnerability Database - the U.S. government repository of vulnerability data",
        },
        {
          term: "Vulnerability",
          description: "A security weakness that can be exploited by attackers",
        },
        {
          term: "Exploit",
          description:
            "Code or technique that takes advantage of a vulnerability",
        },
        {
          term: "Mitigation",
          description:
            "Actions taken to reduce the risk or impact of a security vulnerability",
        },
      ];

      let jargonIndex = 0;
      while (jargons.length < 3 && jargonIndex < fallbackJargons.length) {
        const existingJargon = jargons.find(
          (j) =>
            j.term.toLowerCase() ===
            fallbackJargons[jargonIndex].term.toLowerCase()
        );
        if (!existingJargon) {
          jargons.push(fallbackJargons[jargonIndex]);
        }
        jargonIndex++;
      }

      const dynamicTags = await generateDynamicTags(userQuestion, null, answer);

      console.log(
        "[graphRAGAnswer] Latest CVE response generated successfully"
      );
      return {
        answer,
        reasoningTrace,
        jargons,
        cveDescriptionsMap: {},
        dynamicTags,
        contextData: null,
        sourceLinks: ["https://nvd.nist.gov/"],
      };
    } catch (error) {
      console.error("[graphRAGAnswer] Error fetching latest CVEs:", error);
      // Continue with normal processing
    }
  }

  // Step 1: Get context from knowledge graph
  let context;
  let enrichmentAlreadyPerformed = false; // Track if enrichment was done in Step 2
  let nvdDirectData = null; // Store NVD direct API data for LLM context
  try {
    context = await getKGContextForQuestion(userQuestion);
    console.log(
      "[graphRAGAnswer] Step 1 Result:",
      context ? "Context found" : "No context found"
    );
  } catch (err) {
    console.error("[graphRAGAnswer] Error in getKGContextForQuestion:", err);
    return {
      answer: "Error in getKGContextForQuestion",
      reasoningTrace: [],
      jargons: [],
      cveDescriptionsMap: {},
      dynamicTags: ["error"],
      contextData: undefined,
      sourceLinks: [],
    };
  }

  // Step 2: Ensure complete context with CVE data, mitigations, and risk levels
  console.log(
    "[graphRAGAnswer] Step 2: Ensuring complete context with all required data"
  );

  let contextComplete =
    context &&
    context.cveIds?.length > 0 &&
    context.cveDescriptions?.length > 0 &&
    context.mitigations?.length > 0 &&
    context.riskLevels?.length > 0 &&
    context.sources?.length > 0;

  // If no context or incomplete context, aggressively search and insert data
  if (!context || !contextComplete) {
    console.log(
      "[graphRAGAnswer] Step 2a: Context missing or incomplete - initiating comprehensive data search"
    );

    try {
      // Step 2a.1: Search web for cybersecurity information
      console.log(
        "[graphRAGAnswer] Step 2a.1: Searching web for cybersecurity information"
      );
      const webFacts = await searchWebAndExtractFacts(userQuestion);

      if (webFacts) {
        // Step 2a.2: Insert facts into knowledge graph
        console.log(
          "[graphRAGAnswer] Step 2a.2: Inserting web facts into knowledge graph"
        );
        await insertFactsIntoKG(webFacts, userQuestion);
      }

      // Step 2a.3: Aggressive CVE enrichment regardless of web facts
      console.log(
        "[graphRAGAnswer] Step 2a.3: Performing aggressive CVE enrichment"
      );
      const enrichmentResult = await enrichConceptWithCVEs(
        userQuestion,
        webFacts,
        userQuestion
      );
      nvdDirectData = enrichmentResult.nvdDirectData;
      enrichmentAlreadyPerformed = true; // Mark that enrichment was done

      // Step 2a.4: Re-query knowledge graph with all new data
      console.log(
        "[graphRAGAnswer] Step 2a.4: Re-querying knowledge graph with comprehensive data"
      );
      context = await getKGContextForQuestion(userQuestion);

      // Step 2a.5: Final check - enrichment already done in Step 2a.3
      contextComplete =
        context &&
        context.cveIds?.length > 0 &&
        context.cveDescriptions?.length > 0 &&
        context.mitigations?.length > 0 &&
        context.riskLevels?.length > 0 &&
        context.sources?.length > 0;

      if (!contextComplete) {
        console.log(
          "[graphRAGAnswer] Step 2a.5: Context still incomplete after enrichment, but skipping duplicate enrichment"
        );
      } else {
        console.log(
          "[graphRAGAnswer] Step 2a.5: Context complete after enrichment"
        );
      }
    } catch (err) {
      console.error(
        "[graphRAGAnswer] Error in comprehensive data search:",
        err
      );
    }
  }

  // COMMENTED OUT RETRY LOGIC FOR TESTING
  /*
    // Add delay and retry up to 2 more times
    let retries = 0;
    while (
      retries < 2 &&
      (!context ||
        !(context as any)?.cveIds?.length ||
        !(context as any)?.cveDescriptions?.length ||
        !(context as any)?.mitigations?.length ||
        !(context as any)?.riskLevels?.length ||
        !(context as any)?.sources?.length)
    ) {
      console.log(`[graphRAGAnswer] Retry #${retries + 1}: Waiting 1s before re-querying context`);
      await new Promise((res) => setTimeout(res, 1000));
      try {
        console.log(`[graphRAGAnswer] Before retry #${retries + 1} getKGContextForQuestion`);
        const TIMEOUT_MS = 5000;
        context = await Promise.race([
          getKGContextForQuestion(userQuestion),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error("Timeout")), TIMEOUT_MS)
          ),
        ]);
        console.log(`[graphRAGAnswer] After retry #${retries + 1} getKGContextForQuestion:`, context);
      } catch (err) {
        console.error(`[graphRAGAnswer] Error in retry #${retries + 1}:`, err);
        break;
      }
      retries++;
    }
    */

  // Step 3: Generate actual answer using LLM
  console.log("[graphRAGAnswer] Step 3: Generating LLM response");

  let answer: string;
  let jargons: Array<{ term: string; description: string }> = [];
  let cveDescriptionsMap: Record<string, string> = {};
  let sourceLinks: Array<{ title: string; url: string; type: string }> = [];

  try {
    const llmAnswer = await answerWithLLM(
      userQuestion,
      context,
      agentPersonality,
      nvdDirectData,
      dastScanResults
    );

    // Check if answer is too short or lacks substance
    answer =
      llmAnswer ||
      "I apologize, but I couldn't generate a response at this time.";

    // Clean any jargon syntax that might have been generated
    answer = answer.replace(/\[JARGON_HIGHLIGHT:[^|]+\|[^\]]+\]/g, (match) => {
      const termMatch = match.match(/\[JARGON_HIGHLIGHT:([^|]+)\|/);
      return termMatch ? termMatch[1] : "";
    });

    // Quality check: ensure answer is comprehensive and not just jargon
    if (answer.length < 200 || answer.split(" ").length < 30) {
      console.log(
        "‚ö†Ô∏è [graphRAGAnswer] Answer too short, generating comprehensive fallback"
      );
      answer = await generateComprehensiveFallbackAnswer(
        userQuestion,
        context,
        agentPersonality,
        nvdDirectData
      );
    }

    // Step 3b: Generate source links based on context
    sourceLinks = generateSourceLinks(context, answer);

    // Step 3c: Extract jargons from the answer
    console.log("[graphRAGAnswer] Step 3c: Extracting jargon terms");

    // Update CVE descriptions map with NVD data
    if (nvdDirectData && nvdDirectData.cveId) {
      cveDescriptionsMap[nvdDirectData.cveId] =
        nvdDirectData.description ||
        nvdDirectData.mitigation ||
        "No description available";
      console.log(
        `[graphRAGAnswer] Updated CVE descriptions map with NVD data for ${nvdDirectData.cveId}`
      );
    }

    // Update CVE descriptions map with DAST scan results
    if (dastScanResults && dastScanResults.vulnerabilities) {
      console.log(
        `[graphRAGAnswer] Processing DAST scan results for CVE extraction...`
      );

      dastScanResults.vulnerabilities.forEach((vuln: any) => {
        if (vuln.relatedCVEs && vuln.relatedCVEs.length > 0) {
          vuln.relatedCVEs.forEach((cve: any) => {
            if (cve.cveId && cve.description) {
              cveDescriptionsMap[cve.cveId] = cve.description;
              console.log(
                `[graphRAGAnswer] Added DAST CVE to descriptions map: ${cve.cveId}`
              );
            }
          });
        }
      });

      console.log(
        `[graphRAGAnswer] DAST CVE extraction complete. Total CVEs in map: ${Object.keys(cveDescriptionsMap).length}`
      );
    }

    if (context && context.concept) {
      jargons.push({
        term: context.concept,
        description: context.conceptDescription || "Cybersecurity concept",
      });
    }

    // Let LLM extract jargon terms from its own response
    try {
      // Enhanced jargon extraction prompt that includes DAST-specific terms
      const dastSpecificTerms = dastScanResults
        ? `
- DAST-specific terms (like "Dynamic Application Security Testing", "security headers", "HSTS", "X-Frame-Options", "Content Security Policy", "mixed content", "clickjacking")
- Web application security concepts (like "cross-site scripting", "SQL injection", "directory traversal", "information disclosure")
- HTTP security headers (like "Strict-Transport-Security", "X-Content-Type-Options", "Referrer-Policy")
- Web vulnerability categories (like "OWASP Top 10", "CWE", "security misconfiguration")`
        : "";

      const jargonExtractionPrompt = `
You are an expert at identifying technical jargon that non-technical users might not understand.

From the following answer, identify 5-8 technical terms or acronyms that a non-technical person (someone who is not a cybersecurity expert or IT professional) would likely need explained.

Focus on:
- Technical acronyms (like XSS, DDoS, RCE, MFA, VPN, SSL, TLS)
- Specialized cybersecurity terms (like "privilege escalation", "zero-day vulnerability", "social engineering")
- Technical concepts that require explanation (like "man-in-the-middle attack", "brute force", "credential stuffing")
- Industry-specific terminology (like "penetration testing", "vulnerability assessment", "incident response")
- Security frameworks and standards (like "OWASP", "NIST", "ISO 27001")
- Authentication and authorization concepts (like "multi-factor authentication", "single sign-on", "role-based access control")${dastSpecificTerms}

IMPORTANT: Return ONLY a valid JSON array. Do not include any markdown formatting, backticks, or additional text.

Expected format:
[
  {
    "term": "exact term as it appears in the text",
    "description": "simple, clear explanation for a non-technical person"
  }
]

Answer to analyze:
${answer}

Return only the JSON array:`;

      const jargonResponse = await openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [
          {
            role: "system",
            content:
              "You are a jargon extraction expert. Return only valid JSON arrays.",
          },
          {
            role: "user",
            content: jargonExtractionPrompt,
          },
        ],
        max_tokens: 500,
        temperature: 0.1,
      });

      const jargonText = jargonResponse.choices[0].message?.content;
      if (jargonText) {
        try {
          // Clean the response text to remove markdown formatting
          let cleanText = jargonText.trim();

          // Remove markdown code blocks if present
          if (cleanText.startsWith("```json")) {
            cleanText = cleanText
              .replace(/^```json\s*/, "")
              .replace(/\s*```$/, "");
          } else if (cleanText.startsWith("```")) {
            cleanText = cleanText.replace(/^```\s*/, "").replace(/\s*```$/, "");
          }

          const extractedJargons = JSON.parse(cleanText);
          if (Array.isArray(extractedJargons)) {
            console.log(
              "[graphRAGAnswer] Successfully extracted jargons:",
              extractedJargons.length
            );
            // Add extracted jargons (avoiding duplicates)
            for (const jargon of extractedJargons) {
              if (jargon.term && jargon.description) {
                const existingJargon = jargons.find(
                  (j) => j.term.toLowerCase() === jargon.term.toLowerCase()
                );
                if (!existingJargon) {
                  jargons.push({
                    term: jargon.term,
                    description: jargon.description,
                  });
                }
              }
            }
          }
        } catch (parseError) {
          console.log(
            "[graphRAGAnswer] Failed to parse jargon JSON:",
            parseError
          );
        }
      }
    } catch (jargonError) {
      console.log("[graphRAGAnswer] Error extracting jargons:", jargonError);
    }

    // Step 3d: Add fallback jargons to ensure at least 3 are always present
    console.log("[graphRAGAnswer] Step 3d: Adding fallback jargons");
    const baseFallbackJargons = [
      {
        term: "Cybersecurity",
        description:
          "The practice of protecting systems, networks, and programs from digital attacks.",
      },
      {
        term: "Vulnerability",
        description:
          "A weakness in a system that can be exploited by attackers to gain unauthorized access.",
      },
      {
        term: "Threat",
        description:
          "Any circumstance or event with the potential to harm an information system.",
      },
      {
        term: "Risk Assessment",
        description:
          "The process of identifying, analyzing, and evaluating potential security risks.",
      },
      {
        term: "Incident Response",
        description:
          "The systematic approach to handling and managing security incidents.",
      },
      {
        term: "Access Control",
        description:
          "Security technique that regulates who or what can view or use resources in a computing environment.",
      },
      {
        term: "Encryption",
        description:
          "The process of encoding information to prevent unauthorized access.",
      },
      {
        term: "Authentication",
        description:
          "The process of verifying the identity of a user or system.",
      },
      {
        term: "Authorization",
        description:
          "The process of determining what resources a user can access.",
      },
      {
        term: "Malware",
        description:
          "Malicious software designed to harm systems or steal information.",
      },
    ];

    // Add DAST-specific fallback jargons if DAST scan results are present
    const dastFallbackJargons = dastScanResults
      ? [
          {
            term: "DAST",
            description:
              "Dynamic Application Security Testing - automated security testing that examines running web applications for vulnerabilities",
          },
          {
            term: "Security Headers",
            description:
              "HTTP response headers that help protect websites from common attacks by instructing browsers on security policies",
          },
          {
            term: "HSTS",
            description:
              "HTTP Strict Transport Security - a security header that forces browsers to only use HTTPS connections",
          },
          {
            term: "X-Frame-Options",
            description:
              "A security header that prevents a website from being embedded in frames, protecting against clickjacking attacks",
          },
          {
            term: "Content Security Policy",
            description:
              "A security header that helps prevent cross-site scripting attacks by controlling which resources can be loaded",
          },
          {
            term: "Mixed Content",
            description:
              "When a secure HTTPS page loads insecure HTTP resources, which can compromise security",
          },
          {
            term: "Clickjacking",
            description:
              "A malicious technique where an attacker tricks users into clicking on hidden elements by overlaying them on legitimate content",
          },
          {
            term: "Cross-Site Scripting (XSS)",
            description:
              "A vulnerability where attackers inject malicious scripts into web pages viewed by other users",
          },
          {
            term: "OWASP",
            description:
              "Open Web Application Security Project - a nonprofit foundation that works to improve software security",
          },
          {
            term: "CWE",
            description:
              "Common Weakness Enumeration - a community-developed list of common software security weaknesses",
          },
        ]
      : [];

    const fallbackJargons = [...baseFallbackJargons, ...dastFallbackJargons];

    // Add fallback jargons until we have at least 3
    let jargonIndex = 0;
    while (jargons.length < 3 && jargonIndex < fallbackJargons.length) {
      // Check if this jargon is already present
      const existingJargon = jargons.find(
        (j) =>
          j.term.toLowerCase() ===
          fallbackJargons[jargonIndex].term.toLowerCase()
      );
      if (!existingJargon) {
        jargons.push(fallbackJargons[jargonIndex]);
      }
      jargonIndex++;
    }

    console.log(
      "[graphRAGAnswer] Step 3d Result: Final jargons count:",
      jargons.length
    );

    // Step 3e: Create CVE descriptions map from context
    if (
      context &&
      context.cveIds?.length > 0 &&
      context.cveDescriptions?.length > 0
    ) {
      context.cveIds.forEach((cveId: string, index: number) => {
        cveDescriptionsMap[cveId] =
          context.cveDescriptions[index] || "CVE description not available";
      });
    }
  } catch (err) {
    console.error("[graphRAGAnswer] Error in Step 3:", err);
    answer =
      "I apologize, but I encountered an error while generating the response. Please try again.";
    jargons = [];
    cveDescriptionsMap = {};
    sourceLinks = [];
  }

  // Step 4: Generate dynamic tags based on question and context
  console.log("[graphRAGAnswer] Step 4: Generating dynamic tags");
  let dynamicTags = ["cybersecurity_general"];
  try {
    dynamicTags = await generateDynamicTags(userQuestion, context, answer);
    console.log("[graphRAGAnswer] Step 4 Result: Generated tags:", dynamicTags);
  } catch (error) {
    console.error("[graphRAGAnswer] Error generating dynamic tags:", error);
    dynamicTags = ["cybersecurity_general"];
  }

  // Step 5: Prepare final response
  console.log("[graphRAGAnswer] Step 5: Preparing final response");

  // Collect reasoning trace from enrichment if it was performed
  let enrichmentReasoningTrace: Array<{ step: string; message: string }> = [];
  // Skip duplicate enrichment - it was already done in Step 2
  if (!contextComplete && !enrichmentAlreadyPerformed) {
    try {
      const enrichmentResult = await enrichConceptWithCVEs(
        userQuestion,
        undefined,
        userQuestion
      );
      if (enrichmentResult && enrichmentResult.reasoningTrace) {
        enrichmentReasoningTrace = enrichmentResult.reasoningTrace;
      }
    } catch (err) {
      console.error(
        "[graphRAGAnswer] Error getting enrichment reasoning trace:",
        err
      );
    }
  } else {
    console.log(
      "[graphRAGAnswer] Skipping duplicate enrichment - already performed in Step 2"
    );
  }

  // Build the complete reasoning trace
  const completeReasoningTrace = [
    {
      step: "Step1",
      message: "Context retrieved from knowledge graph.",
    },
    {
      step: "Step2",
      message: contextComplete
        ? "Context complete - no enrichment needed."
        : "Comprehensive enrichment executed.",
    },
    ...enrichmentReasoningTrace, // Include detailed enrichment reasoning
    {
      step: "Step3",
      message: "Response generated using LLM with context.",
    },
    {
      step: "Step4",
      message: `Dynamic tags generated: ${dynamicTags.join(", ")}`,
    },
  ];

  // Generate narrative reasoning
  console.log("[graphRAGAnswer] Step 5a: Generating narrative reasoning");
  let narrativeReasoning = "";
  try {
    narrativeReasoning = await generateNarrativeReasoning(
      userQuestion,
      context,
      completeReasoningTrace,
      answer,
      agentPersonality
    );
    console.log(
      "[graphRAGAnswer] Step 5a Result: Narrative reasoning generated"
    );
  } catch (error) {
    console.error(
      "[graphRAGAnswer] Error generating narrative reasoning:",
      error
    );
    narrativeReasoning = `I analyzed your question about ${context?.concept || "cybersecurity"} and provided a comprehensive response based on our knowledge base.`;
  }

  // Enhance context data with DAST CVE information
  let enhancedContext = context;
  if (dastScanResults && dastScanResults.vulnerabilities) {
    const dastCveIds = dastScanResults.vulnerabilities
      .filter((vuln: any) => vuln.relatedCVEs && vuln.relatedCVEs.length > 0)
      .flatMap((vuln: any) => vuln.relatedCVEs.map((cve: any) => cve.cveId));

    const dastCveDescriptions = dastScanResults.vulnerabilities
      .filter((vuln: any) => vuln.relatedCVEs && vuln.relatedCVEs.length > 0)
      .flatMap((vuln: any) =>
        vuln.relatedCVEs.map((cve: any) => cve.description)
      );

    enhancedContext = {
      ...context,
      cveIds: [...(context?.cveIds || []), ...dastCveIds],
      cveDescriptions: [
        ...(context?.cveDescriptions || []),
        ...dastCveDescriptions,
      ],
    } as any;

    console.log(
      `[graphRAGAnswer] Enhanced context with ${dastCveIds.length} DAST CVE IDs`
    );
  }

  const finalResponse = {
    answer: answer,
    reasoningTrace: [
      {
        narrative: narrativeReasoning, // Add narrative as first element
      },
      ...completeReasoningTrace, // Include all technical steps
    ],
    jargons: jargons,
    cveDescriptionsMap: cveDescriptionsMap,
    dynamicTags: dynamicTags,
    contextData: enhancedContext,
    sourceLinks: sourceLinks,
  };

  console.log("[graphRAGAnswer] Complete: All steps finished successfully");
  return finalResponse;
}

// Generate contextual related questions based on the answer content
export async function generateRelatedQuestions(
  userQuestion: string,
  aiAnswer: string,
  kgContext: string,
  previousQuestions: string[]
): Promise<string[]> {
  console.log("[generateRelatedQuestions] Generating contextual questions");

  try {
    const questionPrompt = `
You are an expert at generating specific, contextual follow-up questions based on cybersecurity content.

User's Original Question: "${userQuestion}"

AI's Detailed Answer: "${aiAnswer}"

Knowledge Graph Context: "${kgContext || "No additional context available"}"

Previous Questions Asked: ${previousQuestions.join(", ")}

Based on the user's question and the AI's detailed answer above, generate exactly 3 specific, contextual follow-up questions that:

1. Are DIRECTLY related to the MAIN TOPIC of the answer (e.g., if the answer is about SQL injection, questions should be about SQL injection specifically)
2. Reference specific terms, tools, techniques, or concepts mentioned in the answer
3. Ask for deeper details about specific aspects mentioned (not generic questions)
4. Are meaningful and specific to the topic (avoid generic questions like "How to prevent this?" or "What are common risks?")
5. Build upon the knowledge shared in the answer
6. MUST include the main topic/keyword in the question (e.g., "SQL injection", "XSS", "authentication", etc.)

IMPORTANT: 
- Keep questions SHORT and CLEAR (maximum 8-10 words each). Focus on one specific aspect per question.
- DO NOT add quotes around the questions in your response
- Return only the questions, one per line, without numbering or bullet points

Examples of GOOD questions (short and clear):
What are reflected vs stored XSS attacks?
How does input validation prevent XSS attacks?
What are content security policies for XSS?
Which SQL injection tools are most effective?
How do parameterized queries prevent SQL injection?
What are the main CVE severity levels for SQL injection?

Examples of BAD questions (avoid these):
How to prevent this?
What are common risks?
Can you give an example?
What are best practices?
How do I secure this?
What are the differences between stored procedures and prepared statements for SQL injection prevention? (too long)

Generate exactly 3 short, clear, specific questions that would help the user learn more about the specific topics covered in the answer. Each question should be concise and reference specific content from the answer. Return only the questions, one per line, without quotes, numbering, or bullet points.`;

    const questionResponse = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content:
            "You are an expert at generating specific, contextual follow-up questions based on cybersecurity content. Generate exactly 3 questions that are specific to the content provided. IMPORTANT: Questions must include the main topic/keyword (e.g., 'SQL injection', 'XSS', 'authentication') and be directly related to that specific topic. Do not add quotes around the questions. Return only the questions, one per line, without quotes, numbering, or bullet points.",
        },
        {
          role: "user",
          content: questionPrompt,
        },
      ],
      max_tokens: 300,
      temperature: 0.7,
    });

    const generatedQuestions =
      questionResponse.choices[0]?.message?.content?.trim();

    if (!generatedQuestions) {
      throw new Error("No questions generated");
    }

    // Parse the generated questions (they might be numbered or bulleted)
    let questions = generatedQuestions
      .split("\n")
      .map((q) =>
        q
          .replace(/^\d+\.\s*/, "")
          .replace(/^[-*]\s*/, "")
          .trim()
      )
      .filter(
        (q) =>
          q.length > 0 &&
          !q.toLowerCase().includes("example") &&
          !q.toLowerCase().includes("bad question")
      )
      .slice(0, 3);

    // Filter out duplicates with previous questions
    questions = questions.filter(
      (q) =>
        !previousQuestions.some(
          (pq) =>
            pq.toLowerCase().includes(q.toLowerCase()) ||
            q.toLowerCase().includes(pq.toLowerCase())
        )
    );

    // If we don't have enough questions, add some fallback specific questions
    if (questions.length < 3) {
      const fallbackQuestions = generateFallbackQuestions(
        userQuestion,
        aiAnswer
      );
      questions = [...questions, ...fallbackQuestions].slice(0, 3);
    }

    console.log("[generateRelatedQuestions] Generated questions:", questions);
    return questions;
  } catch (error) {
    console.error(
      "[generateRelatedQuestions] Error generating questions:",
      error
    );
    // Fallback to specific questions based on content
    return generateFallbackQuestions(userQuestion, aiAnswer);
  }
}

function generateFallbackQuestions(
  userQuestion: string,
  aiAnswer: string
): string[] {
  const context = (userQuestion + " " + aiAnswer).toLowerCase();
  const questions: string[] = [];

  // Extract main topic from context
  const mainTopic = extractMainTopic(context);

  // Generate specific questions based on content analysis
  if (context.includes("sql injection")) {
    if (context.includes("parameterized")) {
      questions.push("How do parameterized queries prevent SQL injection?");
    }
    if (context.includes("detection")) {
      questions.push("Which SQL injection tools are most effective?");
    }
    if (context.includes("prevention")) {
      questions.push("How does input validation prevent SQL injection?");
    }
    // Add more SQL injection specific questions
    questions.push("What are the main SQL injection attack types?");
    questions.push("How do stored procedures prevent SQL injection?");
  }

  if (context.includes("xss") || context.includes("cross-site scripting")) {
    if (context.includes("reflected")) {
      questions.push("What are reflected vs stored XSS attacks?");
    }
    if (context.includes("dom")) {
      questions.push("How do DOM-based XSS attacks work?");
    }
    if (context.includes("prevention")) {
      questions.push("What are content security policies for XSS?");
    }
    // Add more XSS specific questions
    questions.push("How does input validation prevent XSS attacks?");
    questions.push("What are the main XSS attack vectors?");
  }

  if (context.includes("authentication")) {
    if (context.includes("multi-factor")) {
      questions.push("What are the main MFA types?");
    }
    if (context.includes("password")) {
      questions.push("How does bcrypt password hashing work?");
    }
    if (context.includes("session")) {
      questions.push("What is secure session management?");
    }
  }

  if (context.includes("encryption")) {
    if (context.includes("aes")) {
      questions.push("What are AES-128 vs AES-256?");
    }
    if (context.includes("rsa")) {
      questions.push("How does RSA key length affect security?");
    }
    if (context.includes("tls")) {
      questions.push("What are the latest TLS recommendations?");
    }
  }

  // Add more specific fallbacks based on common cybersecurity topics
  if (context.includes("firewall")) {
    questions.push("What are network vs application firewalls?");
  }
  if (context.includes("vulnerability")) {
    questions.push("Which vulnerability scanning tools work best?");
  }
  if (context.includes("penetration testing")) {
    questions.push("What are the main pentest phases?");
  }

  return questions.slice(0, 3);
}

// Function to extract the main topic from context
function extractMainTopic(context: string): string {
  const topics = [
    "sql injection",
    "xss",
    "cross-site scripting",
    "authentication",
    "authorization",
    "encryption",
    "firewall",
    "vulnerability",
    "penetration testing",
    "malware",
    "phishing",
    "ddos",
    "ransomware",
    "social engineering",
  ];

  for (const topic of topics) {
    if (context.includes(topic)) {
      return topic;
    }
  }

  return "cybersecurity"; // Default fallback
}

// Helper function to check if the question is asking for latest CVEs
function checkIfLatestCVEQuestion(userQuestion: string): boolean {
  const lowerQuestion = userQuestion.toLowerCase();
  const latestCVEPatterns = [
    "latest cve",
    "latest cves",
    "latest vulnerabilities",
    "latest vulnerability",
    "recent cve",
    "recent cves",
    "recent vulnerabilities",
    "recent vulnerability",
    "new cve",
    "new cves",
    "new vulnerabilities",
    "new vulnerability",
    "what are the latest",
    "show me latest",
    "list latest",
    "get latest",
  ];

  const isMatch = latestCVEPatterns.some((pattern) =>
    lowerQuestion.includes(pattern)
  );

  console.log(`üîç [Latest CVE Detection] Question: "${userQuestion}"`);
  console.log(`üîç [Latest CVE Detection] Lowercase: "${lowerQuestion}"`);
  console.log(`üîç [Latest CVE Detection] Matched pattern: ${isMatch}`);

  if (isMatch) {
    const matchedPattern = latestCVEPatterns.find((pattern) =>
      lowerQuestion.includes(pattern)
    );
    console.log(
      `‚úÖ [Latest CVE Detection] Matched pattern: "${matchedPattern}"`
    );
  }

  return isMatch;
}

// Function to fetch latest 10 CVEs from NVD API
async function fetchLatestCVEsFromNVD(): Promise<any[]> {
  console.log("üîÑ [NVD Latest] Fetching latest 10 CVEs from NVD API");

  try {
    // Use date-based filtering like ingest-nvd.ts to get recent CVEs
    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); // Last 7 days

    // Format dates for NVD API (same format as ingest-nvd.ts)
    const formatDateISO = (date: Date): string => {
      return encodeURIComponent(date.toISOString());
    };

    const startDate = formatDateISO(sevenDaysAgo);
    const endDate = formatDateISO(now);

    // NVD API endpoint for recent CVEs (last 7 days, limited to 10 results)
    const nvdUrl = `https://services.nvd.nist.gov/rest/json/cves/2.0?pubStartDate=${startDate}&pubEndDate=${endDate}&resultsPerPage=10`;

    console.log(`üîç [NVD Latest] Using URL: ${nvdUrl}`);
    console.log(
      `üîç [NVD Latest] Date range: ${sevenDaysAgo.toISOString()} to ${now.toISOString()}`
    );

    const response = await fetch(nvdUrl);

    if (!response.ok) {
      throw new Error(
        `NVD API error: ${response.status} ${response.statusText}`
      );
    }

    const data = await response.json();
    let vulnerabilities = data.vulnerabilities || [];

    console.log(
      `‚úÖ [NVD Latest] Successfully fetched ${vulnerabilities.length} CVEs from last 7 days`
    );

    // If no CVEs in last 7 days, try last 30 days
    if (vulnerabilities.length === 0) {
      console.log(
        "üîÑ [NVD Latest] No CVEs in last 7 days, trying last 30 days..."
      );

      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      const startDate30 = formatDateISO(thirtyDaysAgo);
      const endDate30 = formatDateISO(now);

      const fallbackUrl = `https://services.nvd.nist.gov/rest/json/cves/2.0?pubStartDate=${startDate30}&pubEndDate=${endDate30}&resultsPerPage=10`;

      console.log(`üîç [NVD Latest] Fallback URL: ${fallbackUrl}`);

      const fallbackResponse = await fetch(fallbackUrl);
      if (fallbackResponse.ok) {
        const fallbackData = await fallbackResponse.json();
        vulnerabilities = fallbackData.vulnerabilities || [];
        console.log(
          `‚úÖ [NVD Latest] Fallback: Found ${vulnerabilities.length} CVEs from last 30 days`
        );
      }
    }

    // Process and format the CVE data (matching ingest-nvd.ts format)
    const processedCVEs = vulnerabilities.map((vuln: any) => {
      const cve = vuln.cve;

      // CVSS Score - handle both v3.1 and v2.0 properly (same as ingest-nvd.ts)
      const cvssMetricV31 = cve.metrics?.cvssMetricV31?.[0];
      const cvssMetricV2 = cve.metrics?.cvssMetricV2?.[0];

      const cvssScore =
        cvssMetricV31?.cvssData?.baseScore ??
        cvssMetricV2?.cvssData?.baseScore ??
        null;
      const baseSeverity =
        cvssMetricV31?.baseSeverity ?? cvssMetricV2?.baseSeverity ?? null;
      const vectorString =
        cvssMetricV31?.cvssData?.vectorString ??
        cvssMetricV2?.cvssData?.vectorString ??
        null;
      const version = cvssMetricV31 ? "3.1" : cvssMetricV2 ? "2.0" : null;

      // Get English description (same as ingest-nvd.ts)
      const description: string =
        cve.descriptions?.find((d: any) => d.lang === "en")?.value ||
        "No description available";

      return {
        cveId: cve.id,
        description: description,
        severity: baseSeverity || "Unknown",
        cvssScore: cvssScore,
        cvssVector: vectorString,
        version: version,
        publishedDate: cve.published,
        lastModifiedDate: cve.lastModified,
        source: "NVD API",
      };
    });

    return processedCVEs;
  } catch (error) {
    console.error("‚ùå [NVD Latest] Error fetching latest CVEs:", error);
    throw error;
  }
}

// Function to generate comprehensive fallback answer when original answer is too short
async function generateComprehensiveFallbackAnswer(
  userQuestion: string,
  context: any,
  agentPersonality?: string,
  nvdDirectData?: any
): Promise<string> {
  console.log(
    "[generateComprehensiveFallbackAnswer] Generating comprehensive fallback"
  );

  const systemPrompt =
    agentPersonality === "tutor"
      ? `You are an expert cybersecurity teacher. Provide a comprehensive, educational response that thoroughly explains the topic with clear examples and actionable guidance.`
      : agentPersonality === "analyst"
        ? `You are a cybersecurity analyst. Provide a detailed technical analysis with risk assessment and strategic recommendations.`
        : agentPersonality === "investigator"
          ? `You are a cybersecurity investigator. Provide a thorough forensic analysis with detailed investigation steps and evidence-based conclusions.`
          : `You are a cybersecurity expert. Provide a comprehensive response with detailed explanations and practical guidance.`;

  const contextInfo = context
    ? `
Context from knowledge base:
- Concept: ${context.concept || "N/A"}
- CVE IDs: ${context.cveIds?.join(", ") || "None"}
- Mitigations: ${context.mitigations?.join(", ") || "None"}
- Risk Levels: ${context.riskLevels?.join(", ") || "None"}
- Sources: ${context.sources?.join(", ") || "None"}
`
    : "";

  const nvdInfo = nvdDirectData
    ? `
NVD Data:
- CVE ID: ${nvdDirectData.cveId}
- Description: ${nvdDirectData.description}
- Severity: ${nvdDirectData.severity}
- CVSS Score: ${nvdDirectData.cvssScore}
- Mitigation: ${nvdDirectData.mitigation}
`
    : "";

  const prompt = `${systemPrompt}

User Question: "${userQuestion}"

${contextInfo}
${nvdInfo}

Provide a comprehensive, detailed response that includes:

1. **Clear Definition**: What the topic/concept is
2. **Technical Details**: How it works and why it matters
3. **Real-World Examples**: Practical scenarios and use cases
4. **Risk Assessment**: Potential threats and impacts
5. **Mitigation Strategies**: Specific steps to address the issue
6. **Best Practices**: Recommended approaches and guidelines
7. **Implementation Guidance**: How to apply the solutions

Make the response educational, actionable, and comprehensive. Use clear headings and structured format.`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: systemPrompt,
        },
        {
          role: "user",
          content: prompt,
        },
      ],
      max_tokens: 1500,
      temperature: 0.7,
    });

    return (
      response.choices[0].message?.content ||
      "I apologize, but I couldn't generate a comprehensive response at this time."
    );
  } catch (error) {
    console.error("[generateComprehensiveFallbackAnswer] Error:", error);
    return `## Security Guidance üîê

Based on your question about **${userQuestion}**, here's a comprehensive overview:

### Key Concepts
- **Security Implementation**: Implementing robust security measures
- **Risk Management**: Identifying and mitigating potential threats
- **Best Practices**: Following industry-standard security guidelines

### Implementation Recommendations

1. **Access Control Implementation**
   - Implement role-based access controls (RBAC)
   - Use principle of least privilege
   - Regular access reviews and audits

2. **Security Best Practices**
   - Multi-factor authentication (MFA)
   - Regular security assessments
   - Continuous monitoring and logging

3. **Risk Mitigation**
   - Regular vulnerability scanning
   - Security awareness training
   - Incident response planning

### Next Steps
- Review current security policies
- Implement recommended controls
- Schedule regular security assessments
- Monitor and update security measures

For more specific guidance, please ask about particular aspects of these security measures.`;
  }
}

// Function to generate a story-like answer for latest CVEs
async function generateLatestCVEAnswer(
  latestCVEs: any[],
  agentPersonality?: string
): Promise<string> {
  console.log(
    "üìö [Latest CVE] Generating professional educational analysis for latest CVEs"
  );

  // Create context for the latest CVEs
  const cveContext = latestCVEs
    .map(
      (cve) =>
        `CVE ID: ${cve.cveId}
Severity: ${cve.severity}
CVSS Score: ${cve.cvssScore || "Not available"}
Description: ${cve.description}
Published: ${cve.publishedDate}
Source: ${cve.source}`
    )
    .join("\n\n");

  const contextText = `
Latest CVE Data from NVD:
${cveContext}

IMPORTANT: Create a comprehensive, professional educational response about these latest cybersecurity vulnerabilities. Structure your response as a detailed professional analysis that:
1. Introduces the importance of staying updated with latest vulnerabilities in a professional context
2. Systematically analyzes each CVE with complete technical details
3. Uses the specific CVE IDs, severity levels, CVSS scores, and descriptions provided above
4. Explains the technical implications and risk assessment for each vulnerability
5. Provides detailed mitigation strategies and detection methods
6. Concludes with actionable recommendations for vulnerability management and monitoring
7. Includes multiple practical examples and best practices

Make it thorough, educational, and professionally structured while maintaining complete technical accuracy from the NVD data. Focus on comprehensive knowledge transfer in a structured, academic teaching style.
`;

  // Generate agent personality-based system prompt
  const getSystemPrompt = (personality?: string) => {
    switch (personality) {
      case "tutor":
        return `You are an expert cybersecurity teacher specializing in vulnerability analysis and threat intelligence. Your role is to explain vulnerabilities with structured, precise, technical accuracy - NOT as stories or narratives. You are a knowledgeable domain expert who provides clear, educational explanations.

CORE TEACHING PRINCIPLES:
- Provide direct, technical explanations of vulnerabilities
- Present CVE information in structured, logical format
- Explain CVSS scores and severity ratings clearly
- Give concrete mitigation steps and actionable advice
- Clear any doubts about threat vectors and impact
- Use examples and analogies to explain complex attack scenarios

YOUR TEACHING STYLE FOR VULNERABILITIES:
‚úÖ "This CVE affects..." (DIRECT AND FACTUAL)
‚úÖ "The attack vector works as follows: Step 1... Step 2..." (STRUCTURED)
‚úÖ "Think of this vulnerability like..." (ANALOGIES)
‚úÖ "Here's a real example of exploitation..." (PRACTICAL)

‚ùå "Let me tell you the story of this vulnerability..." (NO STORYTELLING)
‚ùå "Once upon a time, a hacker discovered..." (NO NARRATIVE)
‚ùå "Imagine traveling through the threat landscape..." (NO FICTION)

STRUCTURED VULNERABILITY TEACHING FORMAT:
1. **CVE Overview**: ID, CVSS score, severity, and affected systems
2. **Technical Explanation**: What the vulnerability is and how it works
3. **Attack Vector**: Step-by-step explanation of how it can be exploited
4. **Impact Analysis**: What an attacker can achieve (data theft, RCE, etc.)
5. **Real-World Context**: Known exploits or similar past vulnerabilities
6. **Mitigation Steps**: Specific, actionable remediation measures
7. **Detection**: How to check if your systems are vulnerable

EXPLANATION TECHNIQUES FOR CVEs:
- Use tables to present multiple CVEs with their details side-by-side
- Number exploitation steps clearly (Step 1, Step 2, Step 3...)
- Provide code examples of vulnerable vs. patched code
- Use analogies (e.g., "Buffer overflow is like overfilling a cup until it spills")
- Define CVSS metrics in simple terms
- Explain what each severity level means in practical terms
- Compare similar vulnerabilities to show patterns

EMOJI USAGE (MINIMAL & PROFESSIONAL):
- Use sparingly: üéì (education), üîê (security), ‚ö†Ô∏è (critical), üõ°Ô∏è (protection), ‚úÖ (solution), üí° (key insight)
- Maintain professional, academic tone

MARKDOWN FORMATTING:
- Use ## for main sections (e.g., ## Vulnerability Overview, ## How It Works, ## Mitigation Strategies)
- Use ### for subsections (e.g., ### CVE-2024-1234 Details, ### Step-by-Step Exploitation)
- Use tables for comparing multiple CVEs or severity levels
- Use code blocks with syntax highlighting for technical examples
- Use numbered lists (1., 2., 3.) for sequential steps and procedures
- Use bullet points (-) for lists of characteristics, features, affected systems, or recommendations
- Add blank lines between sections for readability
- Use bold (**text**) for CVE IDs, severity levels, CVSS scores, and critical terms
- Use inline code (backticks) for software versions, commands, and configuration items
- Include clear section headers and logical structure

EXAMPLE STRUCTURE FOR LATEST CVE ANALYSIS:
## Current Threat Landscape Overview üéì

[Introduction explaining the importance of monitoring new vulnerabilities]

[Context about the current security environment]

### Why Staying Informed Matters

[Detailed explanation of the importance of CVE monitoring]

## Detailed CVE Analysis üìö

### CVE-XXXX-XXXX: [Vulnerability Name]

**Severity**: [CRITICAL/HIGH/MEDIUM/LOW] ‚ö†Ô∏è

**CVSS Score**: [X.X/10.0]

**Published Date**: [Date]

**Description**:

[Comprehensive explanation of what the vulnerability is]

[Technical details about the flaw]

**Affected Systems**:
- System/Software 1 (versions X.X to Y.Y)
- System/Software 2 (versions X.X to Y.Y)
- System/Software 3 (versions X.X to Y.Y)

**Attack Vector**:

[Detailed explanation of how this vulnerability can be exploited]

[Step-by-step breakdown of potential attack scenarios]

**Impact Analysis**:

[Thorough explanation of what attackers can achieve]

**Key Technical Details**:
- Detail 1 with comprehensive explanation
- Detail 2 with comprehensive explanation
- Detail 3 with comprehensive explanation

### CVE-XXXX-XXXX: [Another Vulnerability]

[Similar detailed structure for each CVE]

## Risk Assessment & Prioritization üîç

### Understanding Severity Levels

**Critical Vulnerabilities**:
[Detailed explanation of critical severity and its implications]

**High Severity Vulnerabilities**:
[Detailed explanation of high severity and its implications]

[Continue for other severity levels]

### CVSS Scoring Explained

[Comprehensive explanation of how CVSS scores work]

[What different score ranges mean in practice]

## Mitigation Strategies ‚úÖ

### Immediate Actions Required

1. **Action 1**: [Detailed explanation]
   - Specific steps to take
   - Commands or procedures
   - Verification methods

2. **Action 2**: [Detailed explanation]
   - Specific steps to take
   - Expected outcomes

### Long-Term Security Measures

1. **Measure 1**: [Detailed explanation]
2. **Measure 2**: [Detailed explanation]

### Detection and Monitoring üîç

**How to Check for Vulnerability**:

\`\`\`bash
# Example commands for vulnerability detection
# Detailed comments explaining each check
\`\`\`

**Monitoring Recommendations**:
- Recommendation 1 with detailed rationale
- Recommendation 2 with detailed rationale

## Best Practices for Vulnerability Management üìä

1. **Practice 1**: [Comprehensive explanation]
   - Implementation details
   - Expected benefits

2. **Practice 2**: [Comprehensive explanation]
   - Implementation details
   - Expected benefits

## Summary & Action Items üìã

**Key Takeaways**:
1. [Essential point 1]
2. [Essential point 2]
3. [Essential point 3]

**Recommended Actions**:
1. [Priority action 1]
2. [Priority action 2]
3. [Priority action 3]

## Further Learning & Resources üìö

**Related Security Topics**:
- Topic 1 - [How it relates to these CVEs]
- Topic 2 - [How it relates to these CVEs]

**Staying Informed**:
- Guidance on vulnerability databases
- Recommended monitoring practices
- Update notification strategies

TONE: Professional, thorough, clear, and educational - like an expert security instructor teaching about current threats in a professional academic or corporate training environment. Focus on comprehensive threat understanding and actionable security guidance, not entertainment.`;

      case "investigator":
        return `You are MIRA, a master cybersecurity detective and threat intelligence analyst. You investigate and present the latest vulnerability data as compelling detective stories that reveal the current threat landscape. Think of yourself as a cybersecurity Sherlock Holmes analyzing the latest case files.

PERSONALITY TRAITS:
- Master cybersecurity detective and threat intelligence analyst üîçüïµÔ∏èüìö
- Transforms latest vulnerability investigations into compelling detective narratives
- Reveals current threats through storytelling and evidence presentation
- Uses phrases like "The latest threat landscape reveals...", "Evidence shows us...", "Let me walk you through today's case files..."
- Creates suspenseful narratives around technical discoveries
- Makes forensic analysis accessible through storytelling

RESPONSE STRUCTURE (Detective Story):
1. Open with a case introduction about the current threat landscape
2. Present the evidence: Walk through each CVE as evidence in the investigation
3. Build the case: Connect technical details as evidence pieces
4. Reveal the truth: Present findings about current threats in a dramatic reveal
5. Provide the verdict: Explain the impact and implications of these latest threats
6. Close with prevention: "How to protect against today's threat landscape..."

DETECTIVE STORYTELLING TECHNIQUES:
- Present latest vulnerabilities as cases to be solved
- Use evidence gathering as plot development
- Create suspense around current threat discoveries
- Frame attackers as antagonists in the story
- Present solutions as justice served against current threats

EMOJI USAGE:
- Use detective-themed emojis: üîçüïµÔ∏èüìöüìñüé≠‚ö°üõ°Ô∏èüö®üí°
- Emphasize mystery, evidence, and case resolution

MARKDOWN FORMATTING REQUIREMENTS (INVESTIGATION-FOCUSED):
CRITICAL: Format your response as a step-by-step investigation of current threats:
- Use ## for main investigation phases (e.g., ## Current Threat Analysis, ## Evidence Collection, ## Solution Implementation)
- Use ### for investigation steps (e.g., ### Step 1: Threat Assessment, ### Step 2: Evidence Gathering, ### Step 3: Solution Development)
- ALWAYS add a blank line after headings before content
- Separate paragraphs with blank lines - NEVER write everything as one paragraph
- Use bullet points (- or *) for evidence findings and current threat observations
- For step-by-step investigation process, use numbered lists: "1. " (not "1." without space)
- Use **bold** for critical evidence and current threat findings
- Structure as a systematic investigation of current threats leading to solution

TONE: Engaging, investigative, narrative-driven, and current - like a cybersecurity detective revealing the latest threat cases`;

      default:
        return `You are MIRA, a knowledgeable cybersecurity assistant. You provide comprehensive information about the latest vulnerabilities in an engaging, story-like format. You help users understand the current threat landscape through compelling narratives.

PERSONALITY TRAITS:
- Knowledgeable cybersecurity assistant and threat intelligence expert üîêüõ°Ô∏èüìä
- Transforms latest vulnerability data into engaging, educational content
- Uses clear explanations and storytelling techniques üìñ‚ú®
- Makes technical information accessible and memorable
- Provides actionable insights about current threats

RESPONSE STRUCTURE (Educational Story):
1. Open with context about staying current with threats
2. Present the latest vulnerabilities as important updates
3. Explain each CVE with its significance and impact
4. Weave technical details into an engaging narrative
5. Provide practical recommendations for threat management
6. Close with encouragement about proactive security

EMOJI USAGE:
- Use security-themed emojis: üîêüõ°Ô∏èüìäüìñüö®üí°üåê
- Emphasize threat landscape, updates, and security insights

MARKDOWN FORMATTING REQUIREMENTS (HELPFUL-FOCUSED):
CRITICAL: Format your response as helpful guidance about current threats:
- Use ## for main guidance sections (e.g., ## Current Threat Overview, ## Key Recommendations)
- Use ### for guidance subsections (e.g., ### Understanding Today's Threats, ### Best Practices)
- ALWAYS add a blank line after headings before content
- Separate paragraphs with blank lines - NEVER write everything as one paragraph
- Use bullet points (- or *) for key points and current threat recommendations
- For step-by-step guidance, use numbered lists: "1. " (not "1." without space)
- Use **bold** for important security concepts and actionable threat management items
- Structure as helpful guidance with clear, actionable information about current threats

TONE: Engaging, informative, and current - like a cybersecurity expert sharing the latest threat intelligence`;
    }
  };

  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { role: "system", content: getSystemPrompt(agentPersonality) },
        {
          role: "user",
          content: `Context:\n${contextText}\n\nUser question: Show me the latest CVEs\n\nIMPORTANT: Base your response on the provided context. Use the specific CVE information from the context to provide accurate, detailed answers. Create an engaging story that presents these latest vulnerabilities in an educational and memorable way.`,
        },
      ],
      max_tokens: 1500,
      temperature: 0.3,
    });

    const answer = completion.choices[0].message?.content;
    console.log("‚úÖ [Latest CVE] Story-like answer generated successfully");
    return answer || "Unable to generate response for latest CVEs.";
  } catch (error) {
    console.error("‚ùå [Latest CVE] Error generating answer:", error);
    throw error;
  }
}
